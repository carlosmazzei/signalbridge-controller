/**
 * @file main.c
 * @brief Main application for the A320 Pico Controller with FreeRTOS
 * @author
 *   - Carlos Mazzei <carlos.mazzei@gmail.com>
 * @date 2020-2024
 *
 * This file contains the core FreeRTOS tasks and initialization code
 * for the A320 Pico Controller project. It configures USB CDC, handles
 * inbound/outbound data using COBS encoding, and manages hardware
 * resources such as keypads, encoders, and ADCs.
 *
 * @copyright
 *   (c) 2020-2024 Carlos Mazzei - All rights reserved.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>

/* FreeRTOS include files */
#include "FreeRTOS.h"
#include "queue.h"
#include "hooks.h"
#include "task.h"
#include "semphr.h"

/* Pico & hardware includes */
#include "pico/stdlib.h"
#include "hardware/watchdog.h"

/* TinyUSB include */
#include "bsp/board.h"
#include "tusb.h"

/* Project modules */
#include "cobs.h"
#include "stdA320.h"
#include "outputs.h"
#include "inputs.h"
#include "data_event.h"
#include "task_props.h"

/* --- Macros ----------------------------------------------------------------*/

/**
 * @brief Size of the cobs encoded reception queue.
 */
#define ENCODED_QUEUE_SIZE 2048

/**
 * @brief Size of the CDC transmit queue.
 */
#define CDC_TRANSMIT_QUEUE_SIZE 2048

/**
 * @brief Data buffer size (used for inbound/outbound data).
 */
#define DATA_BUFFER_SIZE 20

/**
 * @brief Size of the message header (ID + Command + Length).
 */
#define HEADER_SIZE 3

/**
 * @brief Size of the checksum (1 byte).
 */
#define CHECKSUM_SIZE 1

/**
 * @brief Maximum size of the reception buffer.
 */
#define MAX_BUFFER_SIZE (HEADER_SIZE + DATA_BUFFER_SIZE + CHECKSUM_SIZE)

/**
 * @brief Maximum size of the COBS-encoded reception buffer.
 *
 * Calculation: input_length + (n/254) + Packet Marker.
 */
#define MAX_ENCODED_BUFFER_SIZE (DATA_BUFFER_SIZE + (DATA_BUFFER_SIZE + 254)/254 + 1)

/**
 * @brief Data event queue size to store outbound data generated by inputs.
 */
#define DATA_EVENT_QUEUE_SIZE 20

/**
 * @brief Marker indicating the end of a COBS packet.
 */
#define PACKET_MARKER 0x00

/**
 * @brief Panel ID for this device.
 */
#define PANEL_ID 0x01

/**
 * @brief Task priorities.
 */
#define mainCDC_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainUART_TASK_PRIORITY          (tskIDLE_PRIORITY + 1)
#define mainDECODE_TASK_PRIORITY        (tskIDLE_PRIORITY + 1)
#define mainPROCESS_QUEUE_TASK_PRIORITY (tskIDLE_PRIORITY + 1)
#define mainADC_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainKEY_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainENCODER_TASK_PRIORITY       (tskIDLE_PRIORITY + 1)

/**
 * @brief FreeRTOS stack sizes for the tasks.
 */
#define CDC_STACK_SIZE             (3 * configMINIMAL_STACK_SIZE)
#define UART_EVENT_STACK_SIZE      (3 * configMINIMAL_STACK_SIZE)
#define DECODE_RECEPTION_STACK_SIZE (3 * configMINIMAL_STACK_SIZE)
#define PROCESS_OUTBOUND_STACK_SIZE (3 * configMINIMAL_STACK_SIZE)
#define ADC_READ_STACK_SIZE        (4 * configMINIMAL_STACK_SIZE)
#define KEYPAD_STACK_SIZE          (5 * configMINIMAL_STACK_SIZE)
#define ENCODER_READ_STACK_SIZE    (5 * configMINIMAL_STACK_SIZE)

/* --- Enums and Structs -----------------------------------------------------*/

/**
 * @enum statistics_counter_enum_t
 * @brief Enumerates different error types in the system.
 */
typedef enum statistics_counter_enum_t
{
	QUEUE_SEND_ERROR,
	QUEUE_RECEIVE_ERROR,
	CDC_QUEUE_SEND_ERROR,
	DISPLAY_OUT_ERROR,
	LED_OUT_ERROR,
	WATCHDOG_ERROR,
	MSG_MALFORMED_ERROR,
	COBS_DECODE_ERROR,
	RECEIVE_BUFFER_OVERFLOW_ERROR,
	CHECKSUM_ERROR,
	BUFFER_OVERFLOW_ERROR,
	UNKNOWN_CMD_ERROR,
	BYTES_SENT,
	BYTES_RECEIVED,
	NUM_STATISTICS_COUNTERS /**< Number of statistics counters */
} statistics_counter_enum_t;

/**
 * @struct statistics_counters_t
 * @brief Holds counters for different error types.
 */
typedef struct statistics_counters_t
{
	uint32_t counters[NUM_STATISTICS_COUNTERS]; /**< Array of statistics counters */
	bool error_state;                  /**< Flag indicating critical error state */
} statistics_counters_t;

/**
 * @enum task_enum_t
 * @brief Enumerates the tasks created in the system.
 */
typedef enum task_enum_t
{
	CDC_TASK,
	CDC_WRITE_TASK,
	UART_EVENT_TASK,
	DECODE_RECEPTION_TASK,
	PROCESS_OUTBOUND_TASK,
	ADC_READ_TASK,
	KEYPAD_TASK,
	ENCODER_READ_TASK,
	NUM_TASKS /**< Number of tasks in the system */
} task_enum_t;

/**
 * @struct cdc_packet_t
 * @brief Holds CDC output queue packets.
 */
typedef struct cdc_packet_t {
	uint8_t length;
	uint8_t data[MAX_ENCODED_BUFFER_SIZE];
} cdc_packet_t;

/* --- Static Global Variables -----------------------------------------------*/

/**
 * @brief Queue to store COBS-encoded received data (one byte per queue entry).
 */
static QueueHandle_t encoded_reception_queue = NULL;

/**
 * @brief Queue to store data events to be sent to the host.
 */
static QueueHandle_t data_event_queue = NULL;

/**
 * @brief Queue to store packets to be sent over USB CDC.
 */
static QueueHandle_t cdc_transmit_queue = NULL;

/**
 * @brief Stores various statistics counters and a global error state.
 */
static statistics_counters_t statistics_counters;

/**
 * @brief Stores properties (such as watermarks) for each task.
 */
static task_props_t task_props[NUM_TASKS];

/**
 * @brief Global variable to track CDC RTS flow control.
 */
static volatile bool cdc_rts = false;

/**
 * @brief Global variable to track CDC DTR flow control.
 */
static volatile bool cdc_dtr = false;

/* --- Static Function Prototypes --------------------------------------------*/

/**
 * @brief Calculates the XOR checksum.
 *
 * @param[in] data   Pointer to the data.
 * @param[in] length Length of the data.
 * @return The calculated XOR checksum.
 */
static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length);

/**
 * @brief Task that receives data from UART (USB CDC) and posts to a reception queue.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void uart_event_task(void *pvParameters);

/**
 * @brief FreeRTOS task that runs TinyUSB device tasks.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void cdc_task(void *pvParameters);

/**
 * @brief Encodes and sends data via USB CDC, appending a packet marker at the end.
 *
 * @param[in] id         The ID of the device sending the data.
 * @param[in] command    The command to send.
 * @param[in] send_data  Pointer to the data to send.
 * @param[in] length     Length of the data to send.
 */
static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length);

/**
 * @brief Sends specific error counter status to the host.
 *
 * @param[in] index Index of the error counter to be sent.
 */
static inline void send_status(uint8_t index);

/**
 * @brief Sends the heap usage (high watermark) of each task to the host.
 */
void send_heap_status(uint8_t index);

/**
 * @brief Processes a fully decoded inbound message.
 *
 * @param[in] rx_buffer Pointer to the data buffer containing decoded bytes.
 * @param[in] length    Length of the decoded data.
 */
static void process_inbound_data(const uint8_t *rx_buffer, size_t length);

/**
 * @brief Task that decodes bytes from the encoded reception queue using COBS.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void decode_reception_task(void *pvParameters);

/**
 * @brief Task that processes outbound messages from the `data_event_queue`.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void process_outbound_task(void *pvParameters);

/**
 * @brief Task that processes CDC writes from the `cdc_transmit_queue`.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void cdc_write_task(void *pvParameters);

/**
 * @brief Sets up and initializes all required hardware resources.
 *
 * @return `true` if initialization was successful, `false` otherwise.
 */
static inline bool setup_hardware(void);

/**
 * @brief Enters an infinite loop indicating a critical error state.
 *        The LED blinks and the watchdog is updated periodically.
 */
static inline void enter_error_state(void);

/**
 * @brief Cleans up all allocated resources such as queues and tasks.
 */
static inline void clean_up(void);

/**
 * @brief Callback invoked when line state changes (DTR, RTS).
 *
 * @param[in] itf Interface number
 * @param[in] dtr Data Terminal Ready state
 * @param[in] rts Request To Send state
 */
void tud_cdc_line_state_cb(uint8_t itf, bool dtr, bool rts);

/* --- Function Definitions --------------------------------------------------*/

void tud_cdc_line_state_cb(uint8_t itf, bool dtr, bool rts)
{
	(void)itf;
	cdc_dtr = dtr;
	cdc_rts = rts;
}

uint32_t ulPortGetRunTime( void )
{
	return time_us_32();
}

static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length)
{
	uint8_t checksum = 0;
	for (uint8_t i = 0; i < length; i++)
	{
		checksum ^= data[i];
	}
	return checksum;
}

static void uart_event_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];

	for (;;)
	{
		/* Track free stack space for debugging */
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();

		if (!tud_cdc_n_available(0))
		{
			/* No data available, yield to other tasks */
			taskYIELD();
			continue;
		}

		uint32_t count = tud_cdc_n_read(0, receive_buffer, sizeof(receive_buffer));
		statistics_counters.counters[BYTES_RECEIVED] += count;
		for (uint32_t i = 0; (i < count) && (i < MAX_ENCODED_BUFFER_SIZE); i++)
		{
			if (xQueueSend(encoded_reception_queue, &receive_buffer[i], pdMS_TO_TICKS(5)) != pdTRUE)
			{
				statistics_counters.counters[QUEUE_SEND_ERROR]++;
			}
			watchdog_update();
		}
	}
}

static void cdc_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	for (;;)
	{
		/* TinyUSB device tasks */
		tud_task();

		if (tud_cdc_n_connected(0))
		{
			gpio_put(PICO_DEFAULT_LED_PIN, 1);
		}
		else
		{
			gpio_put(PICO_DEFAULT_LED_PIN, 0);
		}

		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
		vTaskDelay(pdMS_TO_TICKS(2));
	}
}

static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length)
{
	uint8_t uart_outbound_buffer[DATA_BUFFER_SIZE];

	/* Check for buffer overflow risk */
	if (length > (DATA_BUFFER_SIZE - HEADER_SIZE - CHECKSUM_SIZE))
	{
		statistics_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		return;
	}

	/* Compose header */
	id <<= 5;
	uart_outbound_buffer[0] = (id >> 8);
	uart_outbound_buffer[1] = (id & 0xE0) | (command & 0x1F);
	uart_outbound_buffer[2] = length;

	memcpy(&uart_outbound_buffer[HEADER_SIZE], send_data, length);

	/* Calculate and store checksum */
	uint8_t checksum = calculate_checksum(uart_outbound_buffer, (uint8_t)(length + HEADER_SIZE));
	uart_outbound_buffer[HEADER_SIZE + length] = checksum;

	uint8_t encode_buffer[MAX_ENCODED_BUFFER_SIZE];
	size_t num_encoded = cobs_encode(uart_outbound_buffer, length + HEADER_SIZE + CHECKSUM_SIZE, encode_buffer);

	/* Check for buffer overflow after encoding */
	if (num_encoded + 1 >= MAX_ENCODED_BUFFER_SIZE)
	{
		statistics_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		return;
	}

	/* Append marker */
	encode_buffer[num_encoded] = PACKET_MARKER;

	cdc_packet_t packet;
	packet.length = (uint8_t)num_encoded + 1;
	memcpy(packet.data, encode_buffer, packet.length);

	/* Enqueue data to be sent via USB CDC */
	if (xQueueSend(cdc_transmit_queue, &packet, 0) != pdTRUE)
	{
		statistics_counters.counters[CDC_QUEUE_SEND_ERROR]++;
	}
}

static void cdc_write_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	cdc_packet_t packet;
	for (;;)
	{
		/* Wait for a packet to be sent */
		if (pdTRUE == xQueueReceive(cdc_transmit_queue, &packet, portMAX_DELAY))
		{
			/* Wait until the host is ready to receive data (both DTR & RTS asserted) */
			while (!(cdc_dtr && cdc_rts))
			{
				/* If host is not ready, yield briefly before checking again. */
				vTaskDelay(pdMS_TO_TICKS(5));
			}

			size_t total_written = 0;
			while (total_written < packet.length)
			{
				/* Check how many bytes is available to send */
				uint32_t n_avail = tud_cdc_n_write_available(0);
				uint32_t n_write = MIN(n_avail, packet.length - total_written);
				if (n_write)
				{
					tud_cdc_n_write(0, &packet.data[total_written], n_write);
					total_written += n_write;
				}
				/* Allow TinyUSB to proceed */
				tud_task();
				taskYIELD();
			}
			/* Flush after all possible bytes are written */
			statistics_counters.counters[BYTES_SENT] += total_written;
			tud_cdc_write_flush();
		}
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
	}
}

static inline void send_status(uint8_t index)
{
	uint8_t data[5] = {0, 0, 0, 0, 0};

	/* Return the corresponding statistic if index is valid */
	if (index < NUM_STATISTICS_COUNTERS)
	{
		data[0] = index;
		data[1] = (statistics_counters.counters[index] >> 24) & 0xFF;
		data[2] = (statistics_counters.counters[index] >> 16) & 0xFF;
		data[3] = (statistics_counters.counters[index] >> 8) & 0xFF;
		data[4] = statistics_counters.counters[index] & 0xFF;
	}

	send_data(PANEL_ID, PC_ERROR_STATUS_CMD, data, sizeof(data));
}

void send_heap_status(uint8_t index)
{
	uint8_t data[12] = {0};

	/* Invalid index, return not recognized */
	if (index > NUM_TASKS)
	{
		data[0] = 0xFF;
		send_data(PANEL_ID, PC_TASK_STATUS_CMD, data, 1);
		return;
	}

	uint32_t value = 0;

	/* Valid, but equal to NUM_TASKS, return idle task stats */
	if (index == NUM_TASKS)
	{
		data[0] = index;

		/* Absolute time */
		value = ulTaskGetIdleRunTimeCounter();
		data[1] = (value >> 24) & 0xFF;
		data[2] = (value >> 16) & 0xFF;
		data[3] = (value >> 8) & 0xFF;
		data[4] = value & 0xFF;

		/* Percent time */
		value = ulTaskGetIdleRunTimePercent();
		data[5] = (value >> 24) & 0xFF;
		data[6] = (value >> 16) & 0xFF;
		data[7] = (value >> 8) & 0xFF;
		data[8] = value & 0xFF;

		/* Minimum Ever Free Heap Size */
		value = xPortGetMinimumEverFreeHeapSize();
		data[9] = (value >> 24) & 0xFF;
		data[10] = (value >> 16) & 0xFF;
		data[11] = (value >> 8) & 0xFF;
		data[12] = value & 0xFF;

		send_data(PANEL_ID, PC_TASK_STATUS_CMD, data, sizeof(data));
		return;
	}

	/* Valid indexes */
	data[0] = index;

	/* Absolute time */
	value = ulTaskGetRunTimeCounter(task_props[index].task_handle);
	data[1] = (value >> 24) & 0xFF;
	data[2] = (value >> 16) & 0xFF;
	data[3] = (value >> 8) & 0xFF;
	data[4] = value & 0xFF;

	/* Percentage time */
	value = ulTaskGetRunTimePercent(task_props[index].task_handle);
	data[5] = (value >> 24) & 0xFF;
	data[6] = (value >> 16) & 0xFF;
	data[7] = (value >> 8) & 0xFF;
	data[8] = value & 0xFF;

	/* High watermark */
	value = task_props[index].high_watermark;
	data[9] = (value >> 24) & 0xFF;
	data[10] = (value >> 16) & 0xFF;
	data[11] = (value >> 8) & 0xFF;
	data[12] = value & 0xFF;

	send_data(PANEL_ID, PC_TASK_STATUS_CMD, data, sizeof(data));
}

static void process_inbound_data(const uint8_t *rx_buffer, size_t length)
{
	if (length < (HEADER_SIZE + CHECKSUM_SIZE))
	{
		/* Not enough data to include header + checksum */
		statistics_counters.counters[MSG_MALFORMED_ERROR]++;
		return;
	}

	/* Decode ID, command, and length */
	uint16_t rxID = (uint16_t)(rx_buffer[0] << 3);
	rxID |= ((rx_buffer[1] & 0xE0) >> 5);
	uint8_t cmd = (uint8_t)(rx_buffer[1] & 0x1F);
	uint8_t len = rx_buffer[2];

	if (length != (len + HEADER_SIZE + CHECKSUM_SIZE))
	{
		statistics_counters.counters[MSG_MALFORMED_ERROR]++;
		return;
	}

	if (DATA_BUFFER_SIZE < len)
	{
		statistics_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		return;
	}

	/* Verify checksum */
	uint8_t calculated_checksum = calculate_checksum(rx_buffer, (uint8_t)(len + HEADER_SIZE));
	uint8_t received_checksum = rx_buffer[len + HEADER_SIZE];

	if (calculated_checksum != received_checksum)
	{
		statistics_counters.counters[CHECKSUM_ERROR]++;
		return;
	}

	/* Copy payload data */
	uint8_t decoded_data[DATA_BUFFER_SIZE] = {0};
	memcpy(decoded_data, &rx_buffer[HEADER_SIZE], len);

	switch (cmd)
	{
	case PC_LEDOUT_CMD:
	{
		uint8_t leds[2];
		leds[0] = decoded_data[1];
		leds[1] = decoded_data[2];
		if (!led_out(decoded_data[0], leds, sizeof(leds)))
		{
			statistics_counters.counters[LED_OUT_ERROR]++;
		}
	}
	break;

	case PC_PWM_CMD:
		set_pwm_duty(decoded_data[0]);
		break;

	case PC_DPYCTL_CMD:
	{
		if (display_out(decoded_data, len) != len)
		{
			statistics_counters.counters[DISPLAY_OUT_ERROR]++;
		}
	}
	break;

	case PC_ECHO_CMD:
		send_data(rxID, cmd, decoded_data, len);
		break;

	case PC_ERROR_STATUS_CMD:
		send_status(decoded_data[0]);
		break;

	case PC_TASK_STATUS_CMD:
		send_heap_status(decoded_data[0]);
		break;

	default:
		statistics_counters.counters[UNKNOWN_CMD_ERROR]++;
		break;
	}
}

static void decode_reception_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];
	size_t receive_buffer_index = 0;

	for (;;)
	{
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();

		uint8_t data;
		if (pdFALSE == xQueueReceive(encoded_reception_queue, (void *)&data, portMAX_DELAY))
		{
			statistics_counters.counters[QUEUE_RECEIVE_ERROR]++;
			continue;
		}

		if (PACKET_MARKER == data)
		{
			if (receive_buffer_index <= 0)
			{
				/* Packet marker received but no data in buffer */
				statistics_counters.counters[COBS_DECODE_ERROR]++;
				receive_buffer_index = 0;
				continue;
			}

			uint8_t decode_buffer[receive_buffer_index];
			size_t num_decoded = cobs_decode(receive_buffer, receive_buffer_index, decode_buffer);

			receive_buffer_index = 0;

			if (num_decoded > 0)
			{
				process_inbound_data(decode_buffer, num_decoded);
			}
			else
			{
				statistics_counters.counters[COBS_DECODE_ERROR]++;
			}
		}
		else if (receive_buffer_index < MAX_ENCODED_BUFFER_SIZE - 1)
		{
			receive_buffer[receive_buffer_index++] = data;
		}
		else
		{
			statistics_counters.counters[RECEIVE_BUFFER_OVERFLOW_ERROR]++;
			receive_buffer_index = 0;
		}
	}
}

static void process_outbound_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	for (;;)
	{
		data_events_t data_event;
		if (xQueueReceive(data_event_queue, (void *)&data_event, portMAX_DELAY))
		{
			send_data(PANEL_ID, data_event.command, data_event.data, data_event.data_length);
		}
		else
		{
			statistics_counters.counters[QUEUE_RECEIVE_ERROR]++;
		}

		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
	}
}

static inline bool setup_hardware(void)
{
	/* Initialize standard I/O (UART, etc.) */
	stdio_init_all();

	/* Initialize outputs (LED, PWM, etc.) */
	output_init();

	/* Create data event queue */
	data_event_queue = xQueueCreate(DATA_EVENT_QUEUE_SIZE, sizeof(data_events_t));
	if (NULL == data_event_queue)
	{
		return false;
	}

	/* Inputs configuration (keypad, ADC, etc.) */
	const input_config_t config = {
		.columns               = 8,
		.rows                  = 8,
		.key_settling_time_ms  = 20,
		.input_event_queue     = data_event_queue,
		.adc_banks             = 2,
		.adc_channels          = 8,
		.adc_settling_time_ms  = 100,
		.encoder_settling_time_ms = 10,
		/* Enable encoder on row 8 (last row) */
		.encoder_mask          = { [7] = true }
	};
	input_init(&config);

	/* Reset all error counters */
	for (uint8_t i = 0; i < NUM_STATISTICS_COUNTERS; i++)
	{
		statistics_counters.counters[i] = 0;
	}

	/* Reset task props */
	for (uint8_t i = 0; i < NUM_TASKS; i++)
	{
		task_props[i].high_watermark = 0;
		task_props[i].task_handle    = NULL;
	}

	/* Watchdog 1s, pause on debug */
	watchdog_enable(5000, true);

	return true;
}

static inline void enter_error_state(void)
{
	bool state = true;
	for (;;)
	{
		state = !state;
		gpio_put(PICO_DEFAULT_LED_PIN, state);
		vTaskDelay(pdMS_TO_TICKS(500));
		watchdog_update();
	}
}

static inline void clean_up(void)
{
	/* Delete all queues */
	if (encoded_reception_queue)
	{
		vQueueDelete(encoded_reception_queue);
		encoded_reception_queue = NULL;
	}

	if (data_event_queue)
	{
		vQueueDelete(data_event_queue);
		data_event_queue = NULL;
	}

	if (cdc_transmit_queue)
	{
		vQueueDelete(cdc_transmit_queue);
		cdc_transmit_queue = NULL;
	}

	/* Delete all tasks */
	for (uint8_t t = 0; t < NUM_TASKS; t++)
	{
		if (task_props[t].task_handle != NULL)
		{
			vTaskDelete(task_props[t].task_handle);
			task_props[t].task_handle = NULL;
		}
	}
}

/**
 * @brief Main entry point of the application.
 *
 * This function initializes the system (hardware, queues, tasks),
 * checks for watchdog resets, and starts the FreeRTOS scheduler. If
 * an error is detected, it enters an infinite loop (error state).
 *
 * @return Zero on normal exit. Usually never returns because of FreeRTOS.
 */
int main(void)
{
	BaseType_t success;
	statistics_counters.error_state = false;

	/* Create core masks */
	UBaseType_t uxCore0Affinity = (1 << 0);  // Core 0 only
	UBaseType_t uxCore1Affinity = (1 << 1);  // Core 1 only

	if (watchdog_caused_reboot())
	{
		statistics_counters.counters[WATCHDOG_ERROR]++;
		clean_up();
	}

	/* Initialize TinyUSB hardware/board */
	board_init();

	/* Initialize TinyUSB stack */
	if (!tud_init(BOARD_TUD_RHPORT))
	{
		statistics_counters.error_state = true;
	}

	/* Setup hardware, queues, etc. */
	if (!setup_hardware())
	{
		statistics_counters.error_state = true;
	}

	/* Create the CDC task */
	success = xTaskCreate(cdc_task,
	                      "cdc_task",
	                      CDC_STACK_SIZE,
	                      (void *)&task_props[CDC_TASK],
	                      mainCDC_TASK_PRIORITY,
	                      &task_props[CDC_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Create queue for encoded data */
	encoded_reception_queue = xQueueCreate(ENCODED_QUEUE_SIZE, sizeof(uint8_t));
	if (encoded_reception_queue != NULL)
	{
		/* UART event task */
		success = xTaskCreate(uart_event_task,
		                      "uart_event_task",
		                      UART_EVENT_STACK_SIZE,
		                      (void *)&task_props[UART_EVENT_TASK],
		                      mainUART_TASK_PRIORITY,
		                      &task_props[UART_EVENT_TASK].task_handle);
		if (success != pdPASS)
		{
			statistics_counters.error_state = true;
		}

		/* Decode reception task */
		success = xTaskCreate(decode_reception_task,
		                      "decode_reception_task",
		                      DECODE_RECEPTION_STACK_SIZE,
		                      (void *)&task_props[DECODE_RECEPTION_TASK],
		                      mainDECODE_TASK_PRIORITY,
		                      &task_props[DECODE_RECEPTION_TASK].task_handle);
		if (success != pdPASS)
		{
			statistics_counters.error_state = true;
		}
	}
	else
	{
		statistics_counters.error_state = true;
	}

	/* CDC writer queue */
	cdc_transmit_queue = xQueueCreate(CDC_TRANSMIT_QUEUE_SIZE, sizeof(cdc_packet_t));
	if (cdc_transmit_queue != NULL)
	{
		/* CDC write task */
		success = xTaskCreate(cdc_write_task,
		                      "cdc_write_task",
		                      CDC_STACK_SIZE,
		                      (void *)&task_props[CDC_WRITE_TASK],
		                      mainCDC_TASK_PRIORITY,
		                      &task_props[CDC_WRITE_TASK].task_handle);
		if (success != pdPASS)
		{
			statistics_counters.error_state = true;
		}
	}
	else
	{
		statistics_counters.error_state = true;
	}

	/* Outbound processing task */
	success = xTaskCreate(process_outbound_task,
	                      "process_outbound_task",
	                      PROCESS_OUTBOUND_STACK_SIZE,
	                      (void *)&task_props[PROCESS_OUTBOUND_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[PROCESS_OUTBOUND_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* ADC read task */
	success = xTaskCreate(adc_read_task,
	                      "adc_read_task",
	                      ADC_READ_STACK_SIZE,
	                      (void *)&task_props[ADC_READ_TASK],
	                      mainADC_TASK_PRIORITY,
	                      &task_props[ADC_READ_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Keypad task */
	success = xTaskCreate(keypad_task,
	                      "keypad_task",
	                      KEYPAD_STACK_SIZE,
	                      (void *)&task_props[KEYPAD_TASK],
	                      mainKEY_TASK_PRIORITY,
	                      &task_props[KEYPAD_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Encoder read task */
	success = xTaskCreate(encoder_read_task,
	                      "encoder_task",
	                      ENCODER_READ_STACK_SIZE,
	                      (void *)&task_props[ENCODER_READ_TASK],
	                      mainENCODER_TASK_PRIORITY,
	                      &task_props[ENCODER_READ_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Assign core affinity */
	vTaskCoreAffinitySet(task_props[CDC_TASK].task_handle, uxCore0Affinity);
	vTaskCoreAffinitySet(task_props[UART_EVENT_TASK].task_handle, uxCore0Affinity);
	vTaskCoreAffinitySet(task_props[CDC_WRITE_TASK].task_handle, uxCore0Affinity);

	vTaskCoreAffinitySet(task_props[DECODE_RECEPTION_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[PROCESS_OUTBOUND_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[ADC_READ_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[KEYPAD_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[ENCODER_READ_TASK].task_handle, uxCore1Affinity);

	/* Start scheduler if no critical error was found */
	if (!statistics_counters.error_state)
	{
		vTaskStartScheduler();
	}
	else
	{
		enter_error_state();
	}

	return 0; /* Normally should never reach here */
}