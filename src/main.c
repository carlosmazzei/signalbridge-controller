/**
 * @file main.c
 * @brief Main application for the A320 Pico Controller with FreeRTOS.
 * @author
 *   Carlos Mazzei <carlos.mazzei@gmail.com>
 * @date 2020-2025
 *
 * @mainpage Signalbridge Controller Firmware
 *
 * ## Overview
 * This project implements the main firmware for the Signalbridge Controller, based on FreeRTOS and designed for the Raspberry Pi Pico.
 *
 * ### Main Features
 * - USB CDC communication with the host (TinyUSB)
 * - COBS encoding/decoding for robust data transmission
 * - FreeRTOS task and event queue management
 * - Hardware control: keypad, encoders, ADCs, LEDs, PWM
 * - System error and statistics monitoring
 * - Watchdog support and critical fault handling
 *
 * ### Code Structure
 * - Hardware and peripheral initialization
 * - FreeRTOS task creation and management
 * - Queue handling for inter-task communication
 * - Host command processing
 * - Event and status reporting to the host
 *
 * ### License
 * (c) 2020-2025 Carlos Mazzei - All rights reserved.
 *
 * @section dependencies Dependencies
 * - FreeRTOS
 * - Raspberry Pi Pico SDK
 * - TinyUSB
 * - COBS (Consistent Overhead Byte Stuffing)
 *
 * @section contact Contact
 * For questions or contributions, contact: carlos.mazzei@gmail.com
 *
 * @section references References
 * - [FreeRTOS](https://www.freertos.org/)
 * - [Raspberry Pi Pico SDK](https://github.com/raspberrypi/pico-sdk)
 * - [TinyUSB](https://github.com/hathach/tinyusb)
 * - [COBS](https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing)
 *
 * @copyright
 *   (c) 2020-2025 Carlos Mazzei - All rights reserved.
 */

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <stdbool.h>

// FreeRTOS include files
#include "FreeRTOS.h"
#include "queue.h"
#include "task.h"

// Pico & hardware includes
#include "pico/stdlib.h"
#include "hardware/watchdog.h"

// TinyUSB include
#include "bsp/board.h"
#include "tusb.h"

// Project modules
#include "cobs.h"
#include "commands.h"
#include "outputs.h"
#include "inputs.h"
#include "data_event.h"
#include "task_props.h"
#include "error_management.h"

// --- Macros ----------------------------------------------------------------

/**
 * @brief Size of the cobs encoded reception queue.
 */
#define ENCODED_QUEUE_SIZE 2048

/**
 * @brief Size of the CDC transmit queue.
 */
#define CDC_TRANSMIT_QUEUE_SIZE 2048

/**
 * @brief Data buffer size (used for inbound/outbound data).
 */
#define DATA_BUFFER_SIZE 20U

/**
 * @brief Size of the message header (ID + Command + Length).
 */
#define HEADER_SIZE 3U

/**
 * @brief Size of the checksum (1 byte).
 */
#define CHECKSUM_SIZE 1U

/**
 * @brief Maximum size of the COBS-encoded reception buffer.
 *
 * Calculation: input_length + (n/254) + Packet Marker.
 */
#define MAX_ENCODED_BUFFER_SIZE (DATA_BUFFER_SIZE + (DATA_BUFFER_SIZE + 254U)/254U + 1U)

/**
 * @brief Data event queue size to store outbound data generated by inputs.
 */
#define DATA_EVENT_QUEUE_SIZE 20

/**
 * @brief Marker indicating the end of a COBS packet.
 */
#define PACKET_MARKER (uint8_t)0x00

/**
 * @brief Panel ID for this device.
 */
#define BOARD_ID 0x01U

/**
 * @brief Task priorities.
 */
#define mainCDC_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainUART_TASK_PRIORITY          (tskIDLE_PRIORITY + 1)
#define mainLED_STATUS_TASK_PRIORITY    (tskIDLE_PRIORITY + 1)
#define mainDECODE_TASK_PRIORITY        (tskIDLE_PRIORITY + 1)
#define mainPROCESS_QUEUE_TASK_PRIORITY (tskIDLE_PRIORITY + 1)
#define mainADC_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainKEY_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainENCODER_TASK_PRIORITY       (tskIDLE_PRIORITY + 1)

/**
 * @brief FreeRTOS stack sizes for the tasks.
 */
#define CDC_STACK_SIZE              (3 * configMINIMAL_STACK_SIZE)
#define UART_EVENT_STACK_SIZE       (3 * configMINIMAL_STACK_SIZE)
#define LED_STATUS_STACK_SIZE       (2 * configMINIMAL_STACK_SIZE)
#define DECODE_RECEPTION_STACK_SIZE (3 * configMINIMAL_STACK_SIZE)
#define PROCESS_OUTBOUND_STACK_SIZE (3 * configMINIMAL_STACK_SIZE)
#define ADC_READ_STACK_SIZE         (4 * configMINIMAL_STACK_SIZE)
#define KEYPAD_STACK_SIZE           (5 * configMINIMAL_STACK_SIZE)
#define ENCODER_READ_STACK_SIZE     (5 * configMINIMAL_STACK_SIZE)

/**
 * @brief Task core affinity
 */
#define CORE_0_AFFINITY (1U << 0U)  // Core 0 only
#define CORE_1_AFFINITY (1U << 1U)  // Core 1 only

/**
 * @brief Core affinity for the CDC task.
 */
#define CDC_TASK_CORE_AFFINITY                  CORE_0_AFFINITY // Also used by CDC Write Task
#define UART_EVENT_TASK_CORE_AFFINITY           CORE_0_AFFINITY
#define LED_STATUS_TASK_CORE_AFFINITY           CORE_0_AFFINITY
#define DECODE_RECEPTION_TASK_CORE_AFFINITY     CORE_1_AFFINITY
#define PROCESS_OUTBOUND_TASK_CORE_AFFINITY     CORE_1_AFFINITY
#define ADC_READ_TASK_CORE_AFFINITY             CORE_1_AFFINITY
#define KEYPAD_TASK_CORE_AFFINITY               CORE_1_AFFINITY
#define ENCODER_READ_TASK_CORE_AFFINITY         CORE_1_AFFINITY

// --- Enums and Structs -----------------------------------------------------

/**
 * @enum task_enum_t
 * @brief Enumerates the tasks created in the system.
 */
typedef enum task_enum_t {
	CDC_TASK,
	CDC_WRITE_TASK,
	UART_EVENT_TASK,
	DECODE_RECEPTION_TASK,
	PROCESS_OUTBOUND_TASK,
	ADC_READ_TASK,
	KEYPAD_TASK,
	ENCODER_READ_TASK,
	LED_STATUS_TASK,
	NUM_TASKS /**< Number of tasks in the system */
} task_enum_t;

/**
 * @struct cdc_packet_t
 * @brief Holds CDC output queue packets.
 */
typedef struct cdc_packet_t {
	uint8_t length;
	uint8_t data[MAX_ENCODED_BUFFER_SIZE];
} cdc_packet_t;

// --- Static Global Variables -----------------------------------------------

/**
 * @brief Queue to store COBS-encoded received data (one byte per queue entry).
 * This queue is used to hold data received from the USB CDC interface before decoding.
 */
static QueueHandle_t encoded_reception_queue = NULL;

/**
 * @brief Queue to store data events to be sent to the host.
 * This queue is used to hold data events generated by inputs (keypad, ADC, etc.)
 */
static QueueHandle_t data_event_queue = NULL;

/**
 * @brief Queue to store packets to be sent over USB CDC.
 * This queue is used to hold data packets that will be sent to the host via USB CDC.
 * Send_data() will enqueue packets here and cdc_write_task() will dequeue them and send to the host.
 */
static QueueHandle_t cdc_transmit_queue = NULL;

/**
 * @brief Stores properties (such as watermarks) for each task.
 */
static task_props_t task_props[NUM_TASKS];

/**
 * @brief Global variable to track CDC RTS flow control.
 */
static volatile bool cdc_rts = false;

/**
 * @brief Global variable to track CDC DTR flow control.
 */
static volatile bool cdc_dtr = false;

// --- Static Function Prototypes --------------------------------------------

/**
 * @brief Calculates the XOR checksum.
 *
 * @param[in] data   Pointer to the data.
 * @param[in] length Length of the data.
 * @return The calculated XOR checksum.
 */
static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length);

/**
 * @brief Task that receives data from UART (USB CDC) and posts to a reception queue.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void uart_event_task(void *pvParameters);

/**
 * @brief FreeRTOS task that runs TinyUSB device tasks.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void cdc_task(void *pvParameters);

/**
 * @brief Encodes and sends data via USB CDC, appending a packet marker at the end.
 *
 * @param[in] id         The ID of the device sending the data.
 * @param[in] command    The command to send.
 * @param[in] send_data  Pointer to the data to send.
 * @param[in] length     Length of the data to send.
 */
static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length);

/**
 * @brief Sends specific error counter status to the host.
 *
 * @param[in] index Index of the error counter to be sent.
 */
static inline void send_status(uint8_t index);

/**
 * @brief Sends the heap usage (high watermark) of each task to the host.
 */
static void send_heap_status(uint8_t index);

/**
 * @brief Processes a fully decoded inbound message.
 *
 * @param[in] rx_buffer Pointer to the data buffer containing decoded bytes.
 * @param[in] length    Length of the decoded data.
 */
static void process_inbound_data(const uint8_t *rx_buffer, size_t length);

/**
 * @brief Task that decodes bytes from the encoded reception queue using COBS.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void decode_reception_task(void *pvParameters);

/**
 * @brief Task that processes outbound messages from the `data_event_queue`.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void process_outbound_task(void *pvParameters);

/**
 * @brief Task that processes CDC writes from the `cdc_transmit_queue`.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void cdc_write_task(void *pvParameters);

/**
 * @brief LED status task.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void led_status_task(void *pvParameters);

/**
 * @brief Sets up and initializes all required hardware resources.
 *
 * @return `true` if initialization was successful, `false` otherwise.
 */
static inline bool setup_hardware(void);

/**
 * @brief Cleans up all allocated resources such as queues and tasks.
 */
static inline void clean_up(void);

/**
 * @brief Callback invoked when line state changes (DTR, RTS).
 *
 * @param[in] itf Interface number
 * @param[in] dtr Data Terminal Ready state
 * @param[in] rts Request To Send state
 */
void tud_cdc_line_state_cb(uint8_t itf, bool dtr, bool rts);

// --- Function Definitions --------------------------------------------------

void tud_cdc_line_state_cb(uint8_t itf, bool dtr, bool rts)
{
	(void)itf;
	cdc_dtr = dtr;
	cdc_rts = rts;
}

// cppcheck-suppress[misra-c2012-8.4] ; Required by FreeRTOS DEVIATION(D5)
uint32_t ulPortGetRunTime( void )
{
	return time_us_32();
}

static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length)
{
	uint8_t checksum = 0;
	for (uint8_t i = 0; i < length; i++)
	{
		checksum ^= data[i];
	}
	return checksum;
}

static void uart_event_task(void *pvParameters)
{
	// cppcheck-suppress[misra-c2012-11.5] ; Required by FreeRTOS DEVIATION(D3)
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];

	for (;;)
	{
		// Track free stack space for debugging
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		update_watchdog_safe();

		if (!tud_cdc_n_available(0))
		{
			// No data available, yield to other tasks
			taskYIELD();
			continue;
		}

		uint32_t count = tud_cdc_n_read(0, receive_buffer, sizeof(receive_buffer));
		statistics_add_to_counter(BYTES_RECEIVED, count);
		for (uint32_t i = 0; (i < count) && (i < MAX_ENCODED_BUFFER_SIZE); i++)
		{
			if (xQueueSend(encoded_reception_queue, &receive_buffer[i], pdMS_TO_TICKS(5)) != pdTRUE)
			{
				statistics_increment_counter(QUEUE_SEND_ERROR);
			}
			update_watchdog_safe();
		}
	}
}

static void cdc_task(void *pvParameters)
{
	// cppcheck-suppress[misra-c2012-11.5] ; Required by FreeRTOS DEVIATION(D3)
	task_props_t *task_prop = (task_props_t *)pvParameters;
	for (;;)
	{
		// TinyUSB device tasks
		tud_task();

		// Update high watermark and safely reset watchdog timer
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		update_watchdog_safe();
		taskYIELD();
	}
}

static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length)
{
	uint8_t uart_outbound_buffer[DATA_BUFFER_SIZE];
	bool error = false;

	// Check for NULL pointer
	if (NULL == send_data)
	{
		statistics_increment_counter(QUEUE_SEND_ERROR);
		error = true;
	}

	// Check for buffer overflow risk
	if ((false == error) && (length > (DATA_BUFFER_SIZE - HEADER_SIZE - CHECKSUM_SIZE)))
	{
		statistics_increment_counter(BUFFER_OVERFLOW_ERROR);
		error = true;
	}

	if (false == error)
	{
		// Compose header
		uint16_t panel_id = id;
		panel_id <<= 5;
		uart_outbound_buffer[0] = (panel_id >> 8);
		uart_outbound_buffer[1] = (panel_id & 0xE0U) | (command & 0x1FU);
		uart_outbound_buffer[2] = length;

		(void)memcpy(&uart_outbound_buffer[HEADER_SIZE], send_data, length); // flawfinder: ignore

		// Calculate and store checksum
		uint8_t checksum = calculate_checksum(uart_outbound_buffer, (uint8_t)(length + HEADER_SIZE));
		uart_outbound_buffer[HEADER_SIZE + length] = checksum;

		uint8_t encode_buffer[MAX_ENCODED_BUFFER_SIZE];
		size_t num_encoded = cobs_encode(uart_outbound_buffer, length + HEADER_SIZE + CHECKSUM_SIZE, encode_buffer);

		// Check for buffer overflow after encoding
		if ((num_encoded + 1U) >= MAX_ENCODED_BUFFER_SIZE)
		{
			statistics_increment_counter(BUFFER_OVERFLOW_ERROR);
		}
		else
		{
			// Append marker
			encode_buffer[num_encoded] = PACKET_MARKER;

			cdc_packet_t packet;
			packet.length = (uint8_t)num_encoded + 1U;
			(void)memcpy(packet.data, encode_buffer, packet.length); // flawfinder: ignore

			// Enqueue data to be sent via USB CDC
			if (xQueueSend(cdc_transmit_queue, &packet, pdMS_TO_TICKS(1)) != pdTRUE)
			{
				statistics_increment_counter(CDC_QUEUE_SEND_ERROR);
			}
		}
	}
}

static void cdc_write_task(void *pvParameters)
{
	// cppcheck-suppress[misra-c2012-11.5] ; Required by FreeRTOS DEVIATION(D3)
	task_props_t *task_prop = (task_props_t *)pvParameters;
	cdc_packet_t packet;
	for (;;)
	{
		// Wait for a packet to be sent
		if (pdTRUE == xQueueReceive(cdc_transmit_queue, &packet, portMAX_DELAY))
		{
			// Wait until the host is ready to receive data (both DTR & RTS asserted)
			while (!(cdc_dtr && cdc_rts))
			{
				// If host is not ready, yield briefly before checking again.
				vTaskDelay(pdMS_TO_TICKS(5));
			}

			size_t total_written = 0;
			while (total_written < packet.length)
			{
				// Check how many bytes is available to send
				uint32_t n_avail = tud_cdc_n_write_available(0);
				uint32_t n_write = MIN(n_avail, packet.length - total_written);
				if (n_write > 0U)
				{
					tud_cdc_n_write(0, &packet.data[total_written], n_write);
					total_written += n_write;
				}
				// Allow TinyUSB to proceed
				tud_task();
				taskYIELD();
			}
			// Flush after all possible bytes are written
			statistics_add_to_counter(BYTES_SENT, total_written);
			tud_cdc_write_flush();
		}
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		update_watchdog_safe();
	}
}

static inline void send_status(uint8_t index)
{
	uint8_t data[5] = {0, 0, 0, 0, 0};

	// Return the corresponding statistic if index is valid
	if (index < (uint8_t)NUM_STATISTICS_COUNTERS)
	{
		data[0] = index;
		uint32_t counter_value = statistics_get_counter(index);
		data[1] = (counter_value >> 24U) & 0xFFU;
		data[2] = (counter_value >> 16U) & 0xFFU;
		data[3] = (counter_value >> 8U) & 0xFFU;
		data[4] = counter_value & 0xFFU;
	}

	send_data(BOARD_ID, PC_ERROR_STATUS_CMD, data, sizeof(data));
}

static void send_heap_status(uint8_t index)
{
	uint8_t data[13] = {0};
	bool done = false;

	// Invalid index, return not recognized
	if (index > (uint8_t)NUM_TASKS)
	{
		data[0] = 0xFF;
		send_data(BOARD_ID, PC_TASK_STATUS_CMD, data, 1);
		done = true;
	}

	if (!done)
	{
		uint32_t value = 0;
		// Valid, but equal to NUM_TASKS, return idle task stats
		if (index == (uint8_t)NUM_TASKS)
		{
			data[0] = index;

			// Absolute time
			value = ulTaskGetIdleRunTimeCounter();
			data[1] = (value >> 24U) & 0xFFU;
			data[2] = (value >> 16U) & 0xFFU;
			data[3] = (value >> 8U) & 0xFFU;
			data[4] = value & 0xFFU;

			// Percent time
			value = ulTaskGetIdleRunTimePercent();
			data[5] = (value >> 24U) & 0xFFU;
			data[6] = (value >> 16U) & 0xFFU;
			data[7] = (value >> 8) & 0xFFU;
			data[8] = value & 0xFFU;

			// Minimum Ever Free Heap Size
			value = xPortGetMinimumEverFreeHeapSize();
			data[9] = (value >> 24U) & 0xFFU;
			data[10] = (value >> 16U) & 0xFFU;
			data[11] = (value >> 8U) & 0xFFU;
			data[12] = value & 0xFFU;

			send_data(BOARD_ID, PC_TASK_STATUS_CMD, data, sizeof(data));
		}
		else
		{
			// Valid indexes
			data[0] = index;

			// Absolute time
			value = ulTaskGetRunTimeCounter(task_props[index].task_handle);
			data[1] = (value >> 24U) & 0xFFU;
			data[2] = (value >> 16U) & 0xFFU;
			data[3] = (value >> 8U) & 0xFFU;
			data[4] = value & 0xFFU;

			// Percentage time
			value = ulTaskGetRunTimePercent(task_props[index].task_handle);
			data[5] = (value >> 24U) & 0xFFU;
			data[6] = (value >> 16U) & 0xFFU;
			data[7] = (value >> 8U) & 0xFFU;
			data[8] = value & 0xFFU;

			// High watermark
			value = task_props[index].high_watermark;
			data[9] = (value >> 24U) & 0xFFU;
			data[10] = (value >> 16U) & 0xFFU;
			data[11] = (value >> 8U) & 0xFFU;
			data[12] = value & 0xFFU;

			send_data(BOARD_ID, PC_TASK_STATUS_CMD, data, sizeof(data));
		}
	}
}

static void process_inbound_data(const uint8_t *rx_buffer, size_t length)
{
	bool done = false;

	if (length < (HEADER_SIZE + CHECKSUM_SIZE))
	{
		statistics_increment_counter(MSG_MALFORMED_ERROR);
		done = true;
	}

	uint16_t rxID = 0U;
	uint8_t cmd = 0U;
	uint8_t len = 0U;
	if (!done)
	{
		// Decode ID, command, and length
		rxID = (uint16_t)(rx_buffer[0] << 3);
		rxID |= ((rx_buffer[1] & 0xE0U) >> 5);
		cmd = (uint8_t)(rx_buffer[1] & 0x1FU);
		len = rx_buffer[2];

		if (length != (len + HEADER_SIZE + CHECKSUM_SIZE))
		{
			statistics_increment_counter(MSG_MALFORMED_ERROR);
			done = true;
		}
	}

	if ((!done) && (DATA_BUFFER_SIZE < len))
	{
		statistics_increment_counter(BUFFER_OVERFLOW_ERROR);
		done = true;
	}

	if ((!done) && (rxID != BOARD_ID))
	{
		statistics_increment_counter(UNKNOWN_CMD_ERROR);
		done = true;
	}

	uint8_t decoded_data[DATA_BUFFER_SIZE] = {0};
	if (!done)
	{
		(void)memcpy(decoded_data, &rx_buffer[HEADER_SIZE], len); // flawfinder: ignore
		uint8_t calculated_checksum = calculate_checksum(rx_buffer, (uint8_t)(len + HEADER_SIZE));
		uint8_t received_checksum = rx_buffer[len + HEADER_SIZE];

		if (calculated_checksum != received_checksum)
		{
			statistics_increment_counter(CHECKSUM_ERROR);
			done = true;
		}
	}

	if (!done)
	{
		switch (cmd)
		{
		case PC_LEDOUT_CMD:
			if (led_out(decoded_data, len) != OUTPUT_OK)
			{
				statistics_increment_counter(LED_OUT_ERROR);
			}
			break;

		case PC_PWM_CMD:
			set_pwm_duty(decoded_data[0]);
			break;

		case PC_DPYCTL_CMD:
			output_result_t result = display_out(decoded_data, len);
			if (result != OUTPUT_OK)
			{
				statistics_increment_counter(DISPLAY_OUT_ERROR);
			}
			break;

		case PC_ECHO_CMD:
			send_data(rxID, cmd, decoded_data, len);
			break;

		case PC_ERROR_STATUS_CMD:
			send_status(decoded_data[0]);
			break;

		case PC_TASK_STATUS_CMD:
			send_heap_status(decoded_data[0]);
			break;

		default:
			statistics_increment_counter(UNKNOWN_CMD_ERROR);
			break;
		}
	}
	// Single point of return
}

static void decode_reception_task(void *pvParameters)
{
	// cppcheck-suppress[misra-c2012-11.5] ; Required by FreeRTOS DEVIATION(D3)
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];
	size_t receive_buffer_index = 0;

	for (;;)
	{
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		update_watchdog_safe();

		uint8_t data;
		if (pdFALSE == xQueueReceive(encoded_reception_queue, (void *)&data, portMAX_DELAY))
		{
			statistics_increment_counter(QUEUE_RECEIVE_ERROR);
			continue;
		}

		if (PACKET_MARKER == data)
		{
			if (0U == receive_buffer_index)
			{
				// Packet marker received but no data in buffer
				statistics_increment_counter(COBS_DECODE_ERROR);
				receive_buffer_index = 0;
				continue;
			}

			uint8_t decode_buffer[MAX_ENCODED_BUFFER_SIZE];
			size_t num_decoded = cobs_decode(receive_buffer, receive_buffer_index, decode_buffer);

			receive_buffer_index = 0;

			if (num_decoded > 0U)
			{
				process_inbound_data(decode_buffer, num_decoded);
			}
			else
			{
				statistics_increment_counter(COBS_DECODE_ERROR);
			}
		}
		else if (receive_buffer_index < MAX_ENCODED_BUFFER_SIZE - 1U)
		{
			receive_buffer[receive_buffer_index] = data;
			receive_buffer_index++;
		}
		else
		{
			statistics_increment_counter(RECEIVE_BUFFER_OVERFLOW_ERROR);
			receive_buffer_index = 0;
		}
	}
}

static void process_outbound_task(void *pvParameters)
{
	// cppcheck-suppress[misra-c2012-11.5,cstyleCast] ; Required by FreeRTOS DEVIATION(D3)
	task_props_t *task_prop = (task_props_t *)pvParameters;

	for (;;)
	{
		data_events_t data_event;
		BaseType_t result = xQueueReceive(data_event_queue, (void *)&data_event, portMAX_DELAY);
		if (pdPASS == result)
		{
			send_data(BOARD_ID, data_event.command, data_event.data, data_event.data_length);
		}
		else if (errQUEUE_EMPTY == result)
		{
			// code
		}
		else
		{
			statistics_increment_counter(QUEUE_RECEIVE_ERROR);
		}

		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		update_watchdog_safe();
	}
}

static void led_status_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;

	for (;;)
	{
		if (true == statistics_is_error_state())
		{
			// Error state - show error pattern
			uint8_t blink_count = (uint8_t)statistics_get_error_type();

			// Show blink pattern using FreeRTOS delays
			for (uint8_t i = 0; i < blink_count; i++) {
				gpio_put(ERROR_LED_PIN, 1);
				vTaskDelay(pdMS_TO_TICKS(BLINK_ON_MS));
				gpio_put(ERROR_LED_PIN, 0);

				if (i < (blink_count - 1))
				{
					vTaskDelay(pdMS_TO_TICKS(BLINK_OFF_MS));
				}
			}

			vTaskDelay(pdMS_TO_TICKS(PATTERN_PAUSE_MS));
		}
		else
		{
			// Normal operation - show USB enumeration status
			if (true == tud_cdc_n_connected(0))
			{
				// USB enumerated and ready - LED ON
				gpio_put(ERROR_LED_PIN, 1);
			}
			else
			{
				// USB not enumerated - LED OFF
				gpio_put(ERROR_LED_PIN, 0);
			}

			// Check USB status every 100ms
			vTaskDelay(pdMS_TO_TICKS(100));
		}

		update_watchdog_safe();
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
	}
}

static inline bool setup_hardware(void)
{
	bool success = true;

	// Initialize standard I/O (UART, etc.)
	stdio_init_all();

	// Initialize outputs (LED, PWM, etc.)
	output_result_t result = output_init();
	if (result != OUTPUT_OK)
	{
		success = false;
	}

	// Create data event queue
	data_event_queue = xQueueCreate(DATA_EVENT_QUEUE_SIZE, sizeof(data_events_t));
	if (NULL == data_event_queue)
	{
		success = false;
	}

	// Inputs configuration (keypad, ADC, etc.)
	const input_config_t config = {
		.columns               = 8,
		.rows                  = 8,
		.key_settling_time_ms  = 20,
		.input_event_queue     = data_event_queue,
		.adc_channels          = 16,
		.adc_settling_time_ms  = 100,
		.encoder_settling_time_ms = 10,
		// Enable encoder on row 8 (last row)
		.encoder_mask          = { [7] = true }
	};

	input_result_t input_result = INPUT_OK;
	input_result = input_init(&config);
	if(input_result != INPUT_OK)
	{
		success = false;
	}

	// Reset all error counters
	statistics_reset_all_counters();

	// Reset task props
	for (uint i = 0; i < NUM_TASKS; i++)
	{
		task_props[i].high_watermark = 0;
		task_props[i].task_handle    = NULL;
	}

	return success;
}

static inline void clean_up(void)
{
	// Delete all queues
	if (NULL != encoded_reception_queue)
	{
		vQueueDelete(encoded_reception_queue);
		encoded_reception_queue = NULL;
	}

	if (NULL != data_event_queue)
	{
		vQueueDelete(data_event_queue);
		data_event_queue = NULL;
	}

	if (NULL != cdc_transmit_queue)
	{
		vQueueDelete(cdc_transmit_queue);
		cdc_transmit_queue = NULL;
	}

	// Delete all tasks
	for (uint t = 0; t < NUM_TASKS; t++)
	{
		if (task_props[t].task_handle != NULL)
		{
			vTaskDelete(task_props[t].task_handle);
			task_props[t].task_handle = NULL;
		}
	}
}

static inline void create_resources()
{
	BaseType_t success;

	// Create the CDC task
	success = xTaskCreate(cdc_task,
	                      "cdc_task",
	                      CDC_STACK_SIZE,
	                      (void *)&task_props[CDC_TASK],
	                      mainCDC_TASK_PRIORITY,
	                      &task_props[CDC_TASK].task_handle);
	if (pdPASS == success)
	{
		vTaskCoreAffinitySet(task_props[CDC_TASK].task_handle, CDC_TASK_CORE_AFFINITY);
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}

	// Create queue for encoded data
	encoded_reception_queue = xQueueCreate(ENCODED_QUEUE_SIZE, sizeof(uint8_t));
	if (encoded_reception_queue != NULL)
	{
		// UART event task
		success = xTaskCreate(uart_event_task,
		                      "uart_event_task",
		                      UART_EVENT_STACK_SIZE,
		                      (void *)&task_props[UART_EVENT_TASK],
		                      mainUART_TASK_PRIORITY,
		                      &task_props[UART_EVENT_TASK].task_handle);
		if (pdPASS == success)
		{
			vTaskCoreAffinitySet(task_props[UART_EVENT_TASK].task_handle, UART_EVENT_TASK_CORE_AFFINITY);
		}
		else
		{
			set_error_state_persistent(ERROR_FREERTOS_STACK);
		}

		// Decode reception task
		success = xTaskCreate(decode_reception_task,
		                      "decode_reception_task",
		                      DECODE_RECEPTION_STACK_SIZE,
		                      (void *)&task_props[DECODE_RECEPTION_TASK],
		                      mainDECODE_TASK_PRIORITY,
		                      &task_props[DECODE_RECEPTION_TASK].task_handle);
		if (pdPASS == success)
		{
			vTaskCoreAffinitySet(task_props[DECODE_RECEPTION_TASK].task_handle, DECODE_RECEPTION_TASK_CORE_AFFINITY);
		}
		else
		{
			set_error_state_persistent(ERROR_FREERTOS_STACK);
		}
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}

	// CDC writer queue
	cdc_transmit_queue = xQueueCreate(CDC_TRANSMIT_QUEUE_SIZE, sizeof(cdc_packet_t));
	if (cdc_transmit_queue != NULL)
	{
		// CDC write task
		success = xTaskCreate(cdc_write_task,
		                      "cdc_write_task",
		                      CDC_STACK_SIZE,
		                      (void *)&task_props[CDC_WRITE_TASK],
		                      mainCDC_TASK_PRIORITY,
		                      &task_props[CDC_WRITE_TASK].task_handle);
		if (pdPASS == success)
		{
			vTaskCoreAffinitySet(task_props[CDC_WRITE_TASK].task_handle, CDC_TASK_CORE_AFFINITY);
		}
		else
		{
			set_error_state_persistent(ERROR_FREERTOS_STACK);
		}
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}

	// Outbound processing task
	success = xTaskCreate(process_outbound_task,
	                      "process_outbound_task",
	                      PROCESS_OUTBOUND_STACK_SIZE,
	                      (void *)&task_props[PROCESS_OUTBOUND_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[PROCESS_OUTBOUND_TASK].task_handle);
	if (pdPASS == success)
	{
		vTaskCoreAffinitySet(task_props[PROCESS_OUTBOUND_TASK].task_handle, PROCESS_OUTBOUND_TASK_CORE_AFFINITY);
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}

	// ADC read task
	success = xTaskCreate(adc_read_task,
	                      "adc_read_task",
	                      ADC_READ_STACK_SIZE,
	                      (void *)&task_props[ADC_READ_TASK],
	                      mainADC_TASK_PRIORITY,
	                      &task_props[ADC_READ_TASK].task_handle);
	if (pdPASS == success)
	{
		vTaskCoreAffinitySet(task_props[ADC_READ_TASK].task_handle, ADC_READ_TASK_CORE_AFFINITY);
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}

	// Keypad task
	success = xTaskCreate(keypad_task,
	                      "keypad_task",
	                      KEYPAD_STACK_SIZE,
	                      (void *)&task_props[KEYPAD_TASK],
	                      mainKEY_TASK_PRIORITY,
	                      &task_props[KEYPAD_TASK].task_handle);
	if (pdPASS == success)
	{
		vTaskCoreAffinitySet(task_props[KEYPAD_TASK].task_handle, KEYPAD_TASK_CORE_AFFINITY);
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}

	// Encoder read task
	success = xTaskCreate(encoder_read_task,
	                      "encoder_task",
	                      ENCODER_READ_STACK_SIZE,
	                      (void *)&task_props[ENCODER_READ_TASK],
	                      mainENCODER_TASK_PRIORITY,
	                      &task_props[ENCODER_READ_TASK].task_handle);
	if (pdPASS == success)
	{
		vTaskCoreAffinitySet(task_props[ENCODER_READ_TASK].task_handle, ENCODER_READ_TASK_CORE_AFFINITY);
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}

	// LED status task
	success = xTaskCreate(led_status_task,
	                      "led_status_task",
	                      LED_STATUS_STACK_SIZE,
	                      (void *)&task_props[LED_STATUS_TASK],
	                      mainLED_STATUS_TASK_PRIORITY,
	                      &task_props[LED_STATUS_TASK].task_handle);
	if (pdPASS == success)
	{
		vTaskCoreAffinitySet(task_props[LED_STATUS_TASK].task_handle, LED_STATUS_TASK_CORE_AFFINITY);
	}
	else
	{
		set_error_state_persistent(ERROR_FREERTOS_STACK);
	}
}

/**
 * @brief Main entry point of the application.
 *
 * This function initializes the system (hardware, queues, tasks),
 * checks for watchdog resets, and starts the FreeRTOS scheduler. If
 * an error is detected, it enters an infinite loop (error state).
 *
 * @return Zero on normal exit. Usually never returns because of FreeRTOS.
 */
int main(void)
{
	// Error detection
	setup_watchdog_with_error_detection(5000);

	// Handle previous errors
	if (true == statistics_is_error_state())
	{
		// Show error pattern for a limited time using busy_wait
		for (int i = 0; i < 8; i++) {
			show_error_pattern_blocking(statistics_get_error_type());
			update_watchdog_safe();
		}

		// Check error count - if too many, stay in error state
		uint32_t error_count = watchdog_hw->scratch[WATCHDOG_ERROR_COUNT_REG];
		statistics_set_counter(WATCHDOG_ERROR, error_count);
		if (error_count > 5)
		{
			// Too many errors - stay in error state and reset
			while (true) {
				show_error_pattern_blocking(statistics_get_error_type());
				update_watchdog_safe();
			}
		}

		// Try to recover - clear error state
		clean_up();
		statistics_clear_error();
	}

	// Initialize TinyUSB hardware/board
	board_init();

	// Initialize TinyUSB stack
	if (!tud_init(BOARD_TUD_RHPORT))
	{
		set_error_state_persistent(ERROR_RESOURCE_ALLOCATION);
	}

	// Setup hardware, queues, etc.
	if (!setup_hardware())
	{
		set_error_state_persistent(ERROR_RESOURCE_ALLOCATION);
	}

	create_resources();

	vTaskStartScheduler();

	// If we reach here, the scheduler failed to start
	set_error_state_persistent(ERROR_SCHEDULER_FAILED);

	// Scheduler failed - use busy_wait for error display
	while (true) {
		show_error_pattern_blocking(ERROR_SCHEDULER_FAILED);
		update_watchdog_safe();
	}

	return 0; // Normally should never reach here
}