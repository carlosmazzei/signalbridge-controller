/**
 * @file main.c
 * @brief Main application for the A320 Pico Controller with FreeRTOS.
 * @author
 *   Carlos Mazzei <carlos.mazzei@gmail.com>
 * @date 2020-2025
 *
 * @mainpage A320 Pico Controller Firmware
 *
 * ## Overview
 * This project implements the main firmware for the A320 Pico Controller, based on FreeRTOS and designed for the Raspberry Pi Pico.
 *
 * ### Main Features
 * - USB CDC communication with the host (TinyUSB)
 * - COBS encoding/decoding for robust data transmission
 * - FreeRTOS task and event queue management
 * - Hardware control: keypad, encoders, ADCs, LEDs, PWM
 * - System error and statistics monitoring
 * - Watchdog support and critical fault handling
 *
 * ### Code Structure
 * - Hardware and peripheral initialization
 * - FreeRTOS task creation and management
 * - Queue handling for inter-task communication
 * - Host command processing
 * - Event and status reporting to the host
 *
 * ### License
 * (c) 2020-2025 Carlos Mazzei - All rights reserved.
 *
 * @section dependencies Dependencies
 * - FreeRTOS
 * - Raspberry Pi Pico SDK
 * - TinyUSB
 * - COBS (Consistent Overhead Byte Stuffing)
 *
 * @section contact Contact
 * For questions or contributions, contact: carlos.mazzei@gmail.com
 *
 * @section references References
 * - [FreeRTOS](https://www.freertos.org/)
 * - [Raspberry Pi Pico SDK](https://github.com/raspberrypi/pico-sdk)
 * - [TinyUSB](https://github.com/hathach/tinyusb)
 * - [COBS](https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing)
 *
 * @copyright
 *   (c) 2020-2025 Carlos Mazzei - All rights reserved.
 */

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <stdbool.h>

// FreeRTOS include files
#include "FreeRTOS.h"
#include "queue.h"
#include "task.h"

/* Pico & hardware includes */
#include "pico/stdlib.h"
#include "hardware/watchdog.h"

/* TinyUSB include */
#include "bsp/board.h"
#include "tusb.h"

/* Project modules */
#include "cobs.h"
#include "commands.h"
#include "outputs.h"
#include "inputs.h"
#include "data_event.h"
#include "task_props.h"

/* --- Macros ----------------------------------------------------------------*/

/**
 * @brief Size of the cobs encoded reception queue.
 */
#define ENCODED_QUEUE_SIZE 2048

/**
 * @brief Size of the CDC transmit queue.
 */
#define CDC_TRANSMIT_QUEUE_SIZE 2048

/**
 * @brief Data buffer size (used for inbound/outbound data).
 */
#define DATA_BUFFER_SIZE 20U

/**
 * @brief Size of the message header (ID + Command + Length).
 */
#define HEADER_SIZE 3U

/**
 * @brief Size of the checksum (1 byte).
 */
#define CHECKSUM_SIZE 1U

/**
 * @brief Maximum size of the reception buffer.
 */
// #define MAX_BUFFER_SIZE (HEADER_SIZE + DATA_BUFFER_SIZE + CHECKSUM_SIZE)

/**
 * @brief Maximum size of the COBS-encoded reception buffer.
 *
 * Calculation: input_length + (n/254) + Packet Marker.
 */
#define MAX_ENCODED_BUFFER_SIZE (DATA_BUFFER_SIZE + (DATA_BUFFER_SIZE + 254U)/254U + 1U)

/**
 * @brief Data event queue size to store outbound data generated by inputs.
 */
#define DATA_EVENT_QUEUE_SIZE 20

/**
 * @brief Marker indicating the end of a COBS packet.
 */
#define PACKET_MARKER (uint8_t)0x00

/**
 * @brief Panel ID for this device.
 */
#define BOARD_ID 0x01U

/**
 * @brief Task priorities.
 */
#define mainCDC_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainUART_TASK_PRIORITY          (tskIDLE_PRIORITY + 1)
#define mainDECODE_TASK_PRIORITY        (tskIDLE_PRIORITY + 1)
#define mainPROCESS_QUEUE_TASK_PRIORITY (tskIDLE_PRIORITY + 1)
#define mainADC_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainKEY_TASK_PRIORITY           (tskIDLE_PRIORITY + 1)
#define mainENCODER_TASK_PRIORITY       (tskIDLE_PRIORITY + 1)

/**
 * @brief FreeRTOS stack sizes for the tasks.
 */
#define CDC_STACK_SIZE             (3 * configMINIMAL_STACK_SIZE)
#define UART_EVENT_STACK_SIZE      (3 * configMINIMAL_STACK_SIZE)
#define DECODE_RECEPTION_STACK_SIZE (3 * configMINIMAL_STACK_SIZE)
#define PROCESS_OUTBOUND_STACK_SIZE (3 * configMINIMAL_STACK_SIZE)
#define ADC_READ_STACK_SIZE        (4 * configMINIMAL_STACK_SIZE)
#define KEYPAD_STACK_SIZE          (5 * configMINIMAL_STACK_SIZE)
#define ENCODER_READ_STACK_SIZE    (5 * configMINIMAL_STACK_SIZE)

/* --- Enums and Structs -----------------------------------------------------*/

/**
 * @enum statistics_counter_enum_t
 * @brief Enumerates different error types in the system.
 */
typedef enum statistics_counter_enum_t { // cppcheck-suppress[misra-c2012-2.4] ; DEVIATION(D3)
	QUEUE_SEND_ERROR,
	QUEUE_RECEIVE_ERROR,
	CDC_QUEUE_SEND_ERROR,
	DISPLAY_OUT_ERROR,
	LED_OUT_ERROR,
	WATCHDOG_ERROR,
	MSG_MALFORMED_ERROR,
	COBS_DECODE_ERROR,
	RECEIVE_BUFFER_OVERFLOW_ERROR,
	CHECKSUM_ERROR,
	BUFFER_OVERFLOW_ERROR,
	UNKNOWN_CMD_ERROR,
	BYTES_SENT,
	BYTES_RECEIVED,
	NUM_STATISTICS_COUNTERS /**< Number of statistics counters */
} statistics_counter_enum_t;

/**
 * @struct statistics_counters_t
 * @brief Holds counters for different error types.
 */
typedef struct statistics_counters_t {
	uint32_t counters[NUM_STATISTICS_COUNTERS]; /**< Array of statistics counters */
	bool error_state;                  /**< Flag indicating critical error state */
} statistics_counters_t;

/**
 * @enum task_enum_t
 * @brief Enumerates the tasks created in the system.
 */
typedef enum task_enum_t {
	CDC_TASK,
	CDC_WRITE_TASK,
	UART_EVENT_TASK,
	DECODE_RECEPTION_TASK,
	PROCESS_OUTBOUND_TASK,
	ADC_READ_TASK,
	KEYPAD_TASK,
	ENCODER_READ_TASK,
	NUM_TASKS /**< Number of tasks in the system */
} task_enum_t;

/**
 * @struct cdc_packet_t
 * @brief Holds CDC output queue packets.
 */
typedef struct cdc_packet_t {
	uint8_t length;
	uint8_t data[MAX_ENCODED_BUFFER_SIZE];
} cdc_packet_t;

/* --- Static Global Variables -----------------------------------------------*/

/**
 * @brief Queue to store COBS-encoded received data (one byte per queue entry).
 */
static QueueHandle_t encoded_reception_queue = NULL;

/**
 * @brief Queue to store data events to be sent to the host.
 */
static QueueHandle_t data_event_queue = NULL;

/**
 * @brief Queue to store packets to be sent over USB CDC.
 */
static QueueHandle_t cdc_transmit_queue = NULL;

/**
 * @brief Stores various statistics counters and a global error state.
 */
static statistics_counters_t statistics_counters;

/**
 * @brief Stores properties (such as watermarks) for each task.
 */
static task_props_t task_props[NUM_TASKS];

/**
 * @brief Global variable to track CDC RTS flow control.
 */
static volatile bool cdc_rts = false;

/**
 * @brief Global variable to track CDC DTR flow control.
 */
static volatile bool cdc_dtr = false;

/* --- Static Function Prototypes --------------------------------------------*/

/**
 * @brief Calculates the XOR checksum.
 *
 * @param[in] data   Pointer to the data.
 * @param[in] length Length of the data.
 * @return The calculated XOR checksum.
 */
static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length);

/**
 * @brief Task that receives data from UART (USB CDC) and posts to a reception queue.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void uart_event_task(void *pvParameters);

/**
 * @brief FreeRTOS task that runs TinyUSB device tasks.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void cdc_task(void *pvParameters);

/**
 * @brief Encodes and sends data via USB CDC, appending a packet marker at the end.
 *
 * @param[in] id         The ID of the device sending the data.
 * @param[in] command    The command to send.
 * @param[in] send_data  Pointer to the data to send.
 * @param[in] length     Length of the data to send.
 */
static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length);

/**
 * @brief Sends specific error counter status to the host.
 *
 * @param[in] index Index of the error counter to be sent.
 */
static inline void send_status(uint8_t index);

/**
 * @brief Sends the heap usage (high watermark) of each task to the host.
 */
static void send_heap_status(uint8_t index);

/**
 * @brief Processes a fully decoded inbound message.
 *
 * @param[in] rx_buffer Pointer to the data buffer containing decoded bytes.
 * @param[in] length    Length of the decoded data.
 */
static void process_inbound_data(const uint8_t *rx_buffer, size_t length);

/**
 * @brief Task that decodes bytes from the encoded reception queue using COBS.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void decode_reception_task(void *pvParameters);

/**
 * @brief Task that processes outbound messages from the `data_event_queue`.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void process_outbound_task(void *pvParameters);

/**
 * @brief Task that processes CDC writes from the `cdc_transmit_queue`.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void cdc_write_task(void *pvParameters);

/**
 * @brief Sets up and initializes all required hardware resources.
 *
 * @return `true` if initialization was successful, `false` otherwise.
 */
static inline bool setup_hardware(void);

/**
 * @brief Enters an infinite loop indicating a critical error state.
 *        The LED blinks and the watchdog is updated periodically.
 */
static inline void enter_error_state(void);

/**
 * @brief Cleans up all allocated resources such as queues and tasks.
 */
static inline void clean_up(void);

/**
 * @brief Callback invoked when line state changes (DTR, RTS).
 *
 * @param[in] itf Interface number
 * @param[in] dtr Data Terminal Ready state
 * @param[in] rts Request To Send state
 */
void tud_cdc_line_state_cb(uint8_t itf, bool dtr, bool rts);

/* --- Function Definitions --------------------------------------------------*/

void tud_cdc_line_state_cb(uint8_t itf, bool dtr, bool rts)
{
	(void)itf;
	cdc_dtr = dtr;
	cdc_rts = rts;
}

/* cppcheck-suppress[misra-c2012-8.4] ; Required by FreeRTOS DEVIATION(D3) */
uint32_t ulPortGetRunTime( void )
{
	return time_us_32();
}

static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length)
{
	uint8_t checksum = 0;
	for (uint8_t i = 0; i < length; i++)
	{
		checksum ^= data[i];
	}
	return checksum;
}

static void uart_event_task(void *pvParameters)
{
	/* cppcheck-suppress[misra-c2012-11.5,cstyleCast] ; Required by FreeRTOS DEVIATION(D3) */
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];

	for (;;)
	{
		/* Track free stack space for debugging */
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();

		if (!tud_cdc_n_available(0))
		{
			/* No data available, yield to other tasks */
			taskYIELD();
			continue;
		}

		uint32_t count = tud_cdc_n_read(0, receive_buffer, sizeof(receive_buffer));
		statistics_counters.counters[BYTES_RECEIVED] += count;
		for (uint32_t i = 0; (i < count) && (i < MAX_ENCODED_BUFFER_SIZE); i++)
		{
			if (xQueueSend(encoded_reception_queue, &receive_buffer[i], pdMS_TO_TICKS(5)) != pdTRUE)
			{
				statistics_counters.counters[QUEUE_SEND_ERROR]++;
			}
			watchdog_update();
		}
	}
}

static void cdc_task(void *pvParameters)
{
	/* cppcheck-suppress[misra-c2012-11.5,cstyleCast] ; Required by FreeRTOS DEVIATION(D3) */
	task_props_t *task_prop = (task_props_t *)pvParameters;
	for (;;)
	{
		/* TinyUSB device tasks */
		tud_task();

		if (true == tud_cdc_n_connected(0))
		{
			gpio_put(PICO_DEFAULT_LED_PIN, 1);
		}
		else
		{
			gpio_put(PICO_DEFAULT_LED_PIN, 0);
		}

		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
		vTaskDelay(pdMS_TO_TICKS(2));
	}
}

static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length)
{
	uint8_t uart_outbound_buffer[DATA_BUFFER_SIZE];
	bool error = false;

	/* Check for NULL pointer */
	if (NULL == send_data)
	{
		statistics_counters.counters[QUEUE_SEND_ERROR]++;
		error = true;
	}

	/* Check for buffer overflow risk */
	if ((false == error) && (length > (DATA_BUFFER_SIZE - HEADER_SIZE - CHECKSUM_SIZE)))
	{
		statistics_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		error = true;
	}

	if (false == error)
	{
		/* Compose header */
		uint16_t panel_id = id;
		panel_id <<= 5;
		uart_outbound_buffer[0] = (panel_id >> 8);
		uart_outbound_buffer[1] = (panel_id & 0xE0U) | (command & 0x1FU);
		uart_outbound_buffer[2] = length;

		(void)memcpy(&uart_outbound_buffer[HEADER_SIZE], send_data, length); // flawfinder: ignore

		/* Calculate and store checksum */
		uint8_t checksum = calculate_checksum(uart_outbound_buffer, (uint8_t)(length + HEADER_SIZE));
		uart_outbound_buffer[HEADER_SIZE + length] = checksum;

		uint8_t encode_buffer[MAX_ENCODED_BUFFER_SIZE];
		size_t num_encoded = cobs_encode(uart_outbound_buffer, length + HEADER_SIZE + CHECKSUM_SIZE, encode_buffer);

		/* Check for buffer overflow after encoding */
		if ((num_encoded + 1U) >= MAX_ENCODED_BUFFER_SIZE)
		{
			statistics_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		}
		else
		{
			/* Append marker */
			encode_buffer[num_encoded] = PACKET_MARKER;

			cdc_packet_t packet;
			packet.length = (uint8_t)num_encoded + 1U;
			(void)memcpy(packet.data, encode_buffer, packet.length); // flawfinder: ignore

			/* Enqueue data to be sent via USB CDC */
			if (xQueueSend(cdc_transmit_queue, &packet, pdMS_TO_TICKS(1)) != pdTRUE)
			{
				statistics_counters.counters[CDC_QUEUE_SEND_ERROR]++;
			}
		}
	}
}

static void cdc_write_task(void *pvParameters)
{
	/* cppcheck-suppress[misra-c2012-11.5,cstyleCast] ; Required by FreeRTOS DEVIATION(D3) */
	task_props_t *task_prop = (task_props_t *)pvParameters;
	cdc_packet_t packet;
	for (;;)
	{
		/* Wait for a packet to be sent */
		if (pdTRUE == xQueueReceive(cdc_transmit_queue, &packet, portMAX_DELAY))
		{
			/* Wait until the host is ready to receive data (both DTR & RTS asserted) */
			while (!(cdc_dtr && cdc_rts))
			{
				/* If host is not ready, yield briefly before checking again. */
				vTaskDelay(pdMS_TO_TICKS(5));
			}

			size_t total_written = 0;
			while (total_written < packet.length)
			{
				/* Check how many bytes is available to send */
				uint32_t n_avail = tud_cdc_n_write_available(0);
				uint32_t n_write = MIN(n_avail, packet.length - total_written);
				if (n_write > 0U)
				{
					tud_cdc_n_write(0, &packet.data[total_written], n_write);
					total_written += n_write;
				}
				/* Allow TinyUSB to proceed */
				tud_task();
				taskYIELD();
			}
			/* Flush after all possible bytes are written */
			statistics_counters.counters[BYTES_SENT] += total_written;
			tud_cdc_write_flush();
		}
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
	}
}

static inline void send_status(uint8_t index)
{
	uint8_t data[5] = {0, 0, 0, 0, 0};

	/* Return the corresponding statistic if index is valid */
	if (index < (uint8_t)NUM_STATISTICS_COUNTERS)
	{
		data[0] = index;
		data[1] = (statistics_counters.counters[index] >> 24U) & 0xFFU;
		data[2] = (statistics_counters.counters[index] >> 16U) & 0xFFU;
		data[3] = (statistics_counters.counters[index] >> 8U) & 0xFFU;
		data[4] = statistics_counters.counters[index] & 0xFFU;
	}

	send_data(BOARD_ID, PC_ERROR_STATUS_CMD, data, sizeof(data));
}

static void send_heap_status(uint8_t index)
{
	uint8_t data[13] = {0};
	bool done = false;

	/* Invalid index, return not recognized */
	if (index > (uint8_t)NUM_TASKS)
	{
		data[0] = 0xFF;
		send_data(BOARD_ID, PC_TASK_STATUS_CMD, data, 1);
		done = true;
	}

	if (!done)
	{
		uint32_t value = 0;
		/* Valid, but equal to NUM_TASKS, return idle task stats */
		if (index == (uint8_t)NUM_TASKS)
		{
			data[0] = index;

			/* Absolute time */
			value = ulTaskGetIdleRunTimeCounter();
			data[1] = (value >> 24U) & 0xFFU;
			data[2] = (value >> 16U) & 0xFFU;
			data[3] = (value >> 8U) & 0xFFU;
			data[4] = value & 0xFFU;

			/* Percent time */
			value = ulTaskGetIdleRunTimePercent();
			data[5] = (value >> 24U) & 0xFFU;
			data[6] = (value >> 16U) & 0xFFU;
			data[7] = (value >> 8) & 0xFFU;
			data[8] = value & 0xFFU;

			/* Minimum Ever Free Heap Size */
			value = xPortGetMinimumEverFreeHeapSize();
			data[9] = (value >> 24U) & 0xFFU;
			data[10] = (value >> 16U) & 0xFFU;
			data[11] = (value >> 8U) & 0xFFU;
			data[12] = value & 0xFFU;

			send_data(BOARD_ID, PC_TASK_STATUS_CMD, data, sizeof(data));
		}
		else
		{
			/* Valid indexes */
			data[0] = index;

			/* Absolute time */
			value = ulTaskGetRunTimeCounter(task_props[index].task_handle);
			data[1] = (value >> 24U) & 0xFFU;
			data[2] = (value >> 16U) & 0xFFU;
			data[3] = (value >> 8U) & 0xFFU;
			data[4] = value & 0xFFU;

			/* Percentage time */
			value = ulTaskGetRunTimePercent(task_props[index].task_handle);
			data[5] = (value >> 24U) & 0xFFU;
			data[6] = (value >> 16U) & 0xFFU;
			data[7] = (value >> 8U) & 0xFFU;
			data[8] = value & 0xFFU;

			/* High watermark */
			value = task_props[index].high_watermark;
			data[9] = (value >> 24U) & 0xFFU;
			data[10] = (value >> 16U) & 0xFFU;
			data[11] = (value >> 8U) & 0xFFU;
			data[12] = value & 0xFFU;

			send_data(BOARD_ID, PC_TASK_STATUS_CMD, data, sizeof(data));
		}
	}
}

static void process_inbound_data(const uint8_t *rx_buffer, size_t length)
{
	bool done = false;

	if (length < (HEADER_SIZE + CHECKSUM_SIZE))
	{
		statistics_counters.counters[MSG_MALFORMED_ERROR]++;
		done = true;
	}

	uint16_t rxID = 0U;
	uint8_t cmd = 0U;
	uint8_t len = 0U;
	if (!done)
	{
		/* Decode ID, command, and length */
		rxID = (uint16_t)(rx_buffer[0] << 3);
		rxID |= ((rx_buffer[1] & 0xE0U) >> 5);
		cmd = (uint8_t)(rx_buffer[1] & 0x1FU);
		len = rx_buffer[2];

		if (length != (len + HEADER_SIZE + CHECKSUM_SIZE))
		{
			statistics_counters.counters[MSG_MALFORMED_ERROR]++;
			done = true;
		}
	}

	if ((!done) && (DATA_BUFFER_SIZE < len))
	{
		statistics_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		done = true;
	}

	if ((!done) && (rxID != BOARD_ID))
	{
		statistics_counters.counters[UNKNOWN_CMD_ERROR]++;
		done = true;
	}

	uint8_t decoded_data[DATA_BUFFER_SIZE] = {0};
	if (!done)
	{
		(void)memcpy(decoded_data, &rx_buffer[HEADER_SIZE], len); // flawfinder: ignore
		uint8_t calculated_checksum = calculate_checksum(rx_buffer, (uint8_t)(len + HEADER_SIZE));
		uint8_t received_checksum = rx_buffer[len + HEADER_SIZE];

		if (calculated_checksum != received_checksum)
		{
			statistics_counters.counters[CHECKSUM_ERROR]++;
			done = true;
		}
	}

	if (!done)
	{
		switch (cmd)
		{
		case PC_LEDOUT_CMD:
			if (led_out(decoded_data, len) != len)
			{
				statistics_counters.counters[LED_OUT_ERROR]++;
			}
			break;

		case PC_PWM_CMD:
			set_pwm_duty(decoded_data[0]);
			break;

		case PC_DPYCTL_CMD:
			if (display_out(decoded_data, len) != len)
			{
				statistics_counters.counters[DISPLAY_OUT_ERROR]++;
			}
			break;

		case PC_ECHO_CMD:
			send_data(rxID, cmd, decoded_data, len);
			break;

		case PC_ERROR_STATUS_CMD:
			send_status(decoded_data[0]);
			break;

		case PC_TASK_STATUS_CMD:
			send_heap_status(decoded_data[0]);
			break;

		default:
			statistics_counters.counters[UNKNOWN_CMD_ERROR]++;
			break;
		}
	}
	/* Single point of return */
}

static void decode_reception_task(void *pvParameters)
{
	/* cppcheck-suppress[misra-c2012-11.5,cstyleCast] ; Required by FreeRTOS DEVIATION(D3) */
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];
	size_t receive_buffer_index = 0;

	for (;;)
	{
		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();

		uint8_t data;
		if (pdFALSE == xQueueReceive(encoded_reception_queue, (void *)&data, portMAX_DELAY))
		{
			statistics_counters.counters[QUEUE_RECEIVE_ERROR]++;
			continue;
		}

		if (PACKET_MARKER == data)
		{
			if (0U == receive_buffer_index)
			{
				/* Packet marker received but no data in buffer */
				statistics_counters.counters[COBS_DECODE_ERROR]++;
				receive_buffer_index = 0;
				continue;
			}

			uint8_t decode_buffer[MAX_ENCODED_BUFFER_SIZE];
			size_t num_decoded = cobs_decode(receive_buffer, receive_buffer_index, decode_buffer);

			receive_buffer_index = 0;

			if (num_decoded > 0U)
			{
				process_inbound_data(decode_buffer, num_decoded);
			}
			else
			{
				statistics_counters.counters[COBS_DECODE_ERROR]++;
			}
		}
		else if (receive_buffer_index < MAX_ENCODED_BUFFER_SIZE - 1U)
		{
			receive_buffer[receive_buffer_index] = data;
			receive_buffer_index++;
		}
		else
		{
			statistics_counters.counters[RECEIVE_BUFFER_OVERFLOW_ERROR]++;
			receive_buffer_index = 0;
		}
	}
}

static void process_outbound_task(void *pvParameters)
{
	/* cppcheck-suppress[misra-c2012-11.5,cstyleCast] ; Required by FreeRTOS DEVIATION(D3) */
	task_props_t *task_prop = (task_props_t *)pvParameters;
	for (;;)
	{
		data_events_t data_event;
		BaseType_t result = xQueueReceive(data_event_queue, (void *)&data_event, portMAX_DELAY);
		if (pdPASS == result)
		{
			send_data(BOARD_ID, data_event.command, data_event.data, data_event.data_length);
		}
		else if (errQUEUE_EMPTY == result)
		{
			/* code */
		}
		else
		{
			statistics_counters.counters[QUEUE_RECEIVE_ERROR]++;
		}

		task_prop->high_watermark = uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
	}
}

static inline bool setup_hardware(void)
{
	bool success = true;
	/* Initialize standard I/O (UART, etc.) */
	stdio_init_all();

	/* Initialize outputs (LED, PWM, etc.) */
	output_result_t result = output_init();
	if (result != OUTPUT_OK)
	{
		success = false;
	}

	/* Create data event queue */
	data_event_queue = xQueueCreate(DATA_EVENT_QUEUE_SIZE, sizeof(data_events_t));
	if (NULL == data_event_queue)
	{
		success = false;
	}

	/* Inputs configuration (keypad, ADC, etc.) */
	const input_config_t config = {
		.columns               = 8,
		.rows                  = 8,
		.key_settling_time_ms  = 20,
		.input_event_queue     = data_event_queue,
		.adc_banks             = 2,
		.adc_channels          = 8,
		.adc_settling_time_ms  = 100,
		.encoder_settling_time_ms = 10,
		/* Enable encoder on row 8 (last row) */
		.encoder_mask          = { [7] = true }
	};

	input_result_t input_result = INPUT_OK;
	input_result = input_init(&config);
	if(input_result != INPUT_OK)
	{
		success = false;
	}

	/* Reset all error counters */
	for (uint i = 0; i < NUM_STATISTICS_COUNTERS; i++)
	{
		statistics_counters.counters[i] = 0;
	}

	/* Reset task props */
	for (uint i = 0; i < NUM_TASKS; i++)
	{
		task_props[i].high_watermark = 0;
		task_props[i].task_handle    = NULL;
	}

	/* Watchdog 1s, pause on debug */
	watchdog_enable(5000, true);

	return success;
}

static inline void enter_error_state(void)
{
	bool state = true; // cppcheck-suppress variableScope
	for (;;)
	{
		state = !state;
		gpio_put(PICO_DEFAULT_LED_PIN, state);
		vTaskDelay(pdMS_TO_TICKS(500));
		watchdog_update();
	}
}

static inline void clean_up(void)
{
	/* Delete all queues */
	if (NULL != encoded_reception_queue)
	{
		vQueueDelete(encoded_reception_queue);
		encoded_reception_queue = NULL;
	}

	if (NULL != data_event_queue)
	{
		vQueueDelete(data_event_queue);
		data_event_queue = NULL;
	}

	if (NULL != cdc_transmit_queue)
	{
		vQueueDelete(cdc_transmit_queue);
		cdc_transmit_queue = NULL;
	}

	/* Delete all tasks */
	for (uint t = 0; t < NUM_TASKS; t++)
	{
		if (task_props[t].task_handle != NULL)
		{
			vTaskDelete(task_props[t].task_handle);
			task_props[t].task_handle = NULL;
		}
	}
}

/**
 * @brief Main entry point of the application.
 *
 * This function initializes the system (hardware, queues, tasks),
 * checks for watchdog resets, and starts the FreeRTOS scheduler. If
 * an error is detected, it enters an infinite loop (error state).
 *
 * @return Zero on normal exit. Usually never returns because of FreeRTOS.
 */
int main(void)
{
	BaseType_t success;
	statistics_counters.error_state = false;

	/* Create core masks */
	UBaseType_t uxCore0Affinity = (1U << 0U);  // Core 0 only
	UBaseType_t uxCore1Affinity = (1U << 1U);  // Core 1 only

	if (true == watchdog_caused_reboot())
	{
		statistics_counters.counters[WATCHDOG_ERROR]++;
		clean_up();
	}

	/* Initialize TinyUSB hardware/board */
	board_init();

	/* Initialize TinyUSB stack */
	if (!tud_init(BOARD_TUD_RHPORT))
	{
		statistics_counters.error_state = true;
	}

	/* Setup hardware, queues, etc. */
	if (!setup_hardware())
	{
		statistics_counters.error_state = true;
	}

	/* Create the CDC task */
	success = xTaskCreate(cdc_task,
	                      "cdc_task",
	                      CDC_STACK_SIZE,
	                      (void *)&task_props[CDC_TASK],
	                      mainCDC_TASK_PRIORITY,
	                      &task_props[CDC_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Create queue for encoded data */
	encoded_reception_queue = xQueueCreate(ENCODED_QUEUE_SIZE, sizeof(uint8_t));
	if (encoded_reception_queue != NULL)
	{
		/* UART event task */
		success = xTaskCreate(uart_event_task,
		                      "uart_event_task",
		                      UART_EVENT_STACK_SIZE,
		                      (void *)&task_props[UART_EVENT_TASK],
		                      mainUART_TASK_PRIORITY,
		                      &task_props[UART_EVENT_TASK].task_handle);
		if (success != pdPASS)
		{
			statistics_counters.error_state = true;
		}

		/* Decode reception task */
		success = xTaskCreate(decode_reception_task,
		                      "decode_reception_task",
		                      DECODE_RECEPTION_STACK_SIZE,
		                      (void *)&task_props[DECODE_RECEPTION_TASK],
		                      mainDECODE_TASK_PRIORITY,
		                      &task_props[DECODE_RECEPTION_TASK].task_handle);
		if (success != pdPASS)
		{
			statistics_counters.error_state = true;
		}
	}
	else
	{
		statistics_counters.error_state = true;
	}

	/* CDC writer queue */
	cdc_transmit_queue = xQueueCreate(CDC_TRANSMIT_QUEUE_SIZE, sizeof(cdc_packet_t));
	if (cdc_transmit_queue != NULL)
	{
		/* CDC write task */
		success = xTaskCreate(cdc_write_task,
		                      "cdc_write_task",
		                      CDC_STACK_SIZE,
		                      (void *)&task_props[CDC_WRITE_TASK],
		                      mainCDC_TASK_PRIORITY,
		                      &task_props[CDC_WRITE_TASK].task_handle);
		if (success != pdPASS)
		{
			statistics_counters.error_state = true;
		}
	}
	else
	{
		statistics_counters.error_state = true;
	}

	/* Outbound processing task */
	success = xTaskCreate(process_outbound_task,
	                      "process_outbound_task",
	                      PROCESS_OUTBOUND_STACK_SIZE,
	                      (void *)&task_props[PROCESS_OUTBOUND_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[PROCESS_OUTBOUND_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* ADC read task */
	success = xTaskCreate(adc_read_task,
	                      "adc_read_task",
	                      ADC_READ_STACK_SIZE,
	                      (void *)&task_props[ADC_READ_TASK],
	                      mainADC_TASK_PRIORITY,
	                      &task_props[ADC_READ_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Keypad task */
	success = xTaskCreate(keypad_task,
	                      "keypad_task",
	                      KEYPAD_STACK_SIZE,
	                      (void *)&task_props[KEYPAD_TASK],
	                      mainKEY_TASK_PRIORITY,
	                      &task_props[KEYPAD_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Encoder read task */
	success = xTaskCreate(encoder_read_task,
	                      "encoder_task",
	                      ENCODER_READ_STACK_SIZE,
	                      (void *)&task_props[ENCODER_READ_TASK],
	                      mainENCODER_TASK_PRIORITY,
	                      &task_props[ENCODER_READ_TASK].task_handle);
	if (success != pdPASS)
	{
		statistics_counters.error_state = true;
	}

	/* Assign core affinity */
	vTaskCoreAffinitySet(task_props[CDC_TASK].task_handle, uxCore0Affinity);
	vTaskCoreAffinitySet(task_props[UART_EVENT_TASK].task_handle, uxCore0Affinity);
	vTaskCoreAffinitySet(task_props[CDC_WRITE_TASK].task_handle, uxCore0Affinity);

	vTaskCoreAffinitySet(task_props[DECODE_RECEPTION_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[PROCESS_OUTBOUND_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[ADC_READ_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[KEYPAD_TASK].task_handle, uxCore1Affinity);
	vTaskCoreAffinitySet(task_props[ENCODER_READ_TASK].task_handle, uxCore1Affinity);

	/* Start scheduler if no critical error was found */
	if (!statistics_counters.error_state)
	{
		vTaskStartScheduler();
	}
	else
	{
		enter_error_state();
	}

	return 0; /* Normally should never reach here */
}