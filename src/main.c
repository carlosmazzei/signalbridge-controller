/**
 * @file main.c
 * @brief Main application for the A320 Pico Controller with FreeRTOS
 * @author
 *   - Carlos Mazzei <email@domain>
 * @date 2020-2024
 *
 * This file contains the core FreeRTOS tasks and initialization code
 * for the A320 Pico Controller project. It configures USB CDC, handles
 * inbound/outbound data using COBS encoding, and manages hardware
 * resources such as keypads, encoders, and ADCs.
 *
 * @copyright
 *   (c) 2020-2024 Carlos Mazzei - All rights reserved.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>

/* FreeRTOS include files */
#include "FreeRTOS.h"
#include "queue.h"
#include "hooks.h"
#include "task.h"
#include "semphr.h"

/* Pico & hardware includes */
#include "pico/stdlib.h"
#include "hardware/watchdog.h"

/* TinyUSB include */
#include "bsp/board.h"
#include "tusb.h"

/* Project modules */
#include "cobs.h"
#include "stdA320.h"
#include "outputs.h"
#include "inputs.h"
#include "data_event.h"
#include "task_props.h"

/* --- Macros ----------------------------------------------------------------*/

/**
 * @brief Size of the cobs encoded reception queue.
 */
#define ENCODED_QUEUE_SIZE 100

/**
 * @brief Data buffer size (used for inbound/outbound data).
 */
#define DATA_BUFFER_SIZE 20

/**
 * @brief Size of the message header (ID + Command + Length).
 */
#define HEADER_SIZE 3

/**
 * @brief Size of the checksum (1 byte).
 */
#define CHECKSUM_SIZE 1

/**
 * @brief Maximum size of the reception buffer.
 */
#define MAX_BUFFER_SIZE (HEADER_SIZE + DATA_BUFFER_SIZE + CHECKSUM_SIZE)

/**
 * @brief Maximum size of the COBS-encoded reception buffer.
 *
 * Calculation: input_length + (n/254) + Packet Marker.
 */
#define MAX_ENCODED_BUFFER_SIZE (DATA_BUFFER_SIZE + (DATA_BUFFER_SIZE + 254)/254 + 1)

/**
 * @brief Data event queue size to store outbound data generated by inputs.
 */
#define DATA_EVENT_QUEUE_SIZE 20

/**
 * @brief Marker indicating the end of a COBS packet.
 */
#define PACKET_MARKER 0x00

/**
 * @brief Panel ID for this device.
 */
#define PANEL_ID 0x01

/**
 * @brief Task priorities.
 */
#define mainPROCESS_QUEUE_TASK_PRIORITY (tskIDLE_PRIORITY + 1)
#define mainCDC_TASK_PRIORITY           (tskIDLE_PRIORITY + 2)

/**
 * @brief FreeRTOS stack sizes for the tasks.
 */
#define CDC_STACK_SIZE             (2 * configMINIMAL_STACK_SIZE)
#define UART_EVENT_STACK_SIZE      (2 * configMINIMAL_STACK_SIZE)
#define DECODE_RECEPTION_STACK_SIZE (2 * configMINIMAL_STACK_SIZE)
#define PROCESS_OUTBOUND_STACK_SIZE (2 * configMINIMAL_STACK_SIZE)
#define ADC_READ_STACK_SIZE        (2 * configMINIMAL_STACK_SIZE)
#define KEYPAD_STACK_SIZE          (2 * configMINIMAL_STACK_SIZE)
#define ENCODER_READ_STACK_SIZE    (2 * configMINIMAL_STACK_SIZE)

/* --- Enums and Structs -----------------------------------------------------*/

/**
 * @enum error_counter_enum_t
 * @brief Enumerates different error types in the system.
 */
typedef enum error_counter_enum_t
{
	QUEUE_SEND_ERROR,
	QUEUE_RECEIVE_ERROR,
	DISPLAY_OUT_ERROR,
	LED_OUT_ERROR,
	WATCHDOG_ERROR,
	MSG_MALFORMED_ERROR,
	RECEIVE_BUFFER_OVERFLOW_ERROR,
	CHECKSUM_ERROR,
	BUFFER_OVERFLOW_ERROR,
	UNKNOWN_CMD_ERROR,
	NUM_ERROR_COUNTERS /**< Number of error counters */
} error_counter_enum_t;

/**
 * @struct error_counters_t
 * @brief Holds counters for different error types.
 */
typedef struct error_counters_t
{
	uint16_t counters[NUM_ERROR_COUNTERS]; /**< Array of error counters */
	bool error_state;                  /**< Flag indicating critical error state */
} error_counters_t;

/**
 * @struct task_handles_t
 * @brief Holds FreeRTOS task handles for created tasks.
 */
typedef struct task_handles_t
{
	TaskHandle_t cdc_task_handle;
	TaskHandle_t uart_event_task_handle;
	TaskHandle_t decode_reception_task_handle;
	TaskHandle_t process_outbound_task_handle;
	TaskHandle_t adc_read_task_handle;
	TaskHandle_t keypad_task_handle;
	TaskHandle_t encoder_read_task_handle;
} task_handles_t;

/**
 * @enum task_enum_t
 * @brief Enumerates the tasks created in the system.
 */
typedef enum task_enum_t
{
	CDC_TASK,
	UART_EVENT_TASK,
	DECODE_RECEPTION_TASK,
	PROCESS_OUTBOUND_TASK,
	ADC_READ_TASK,
	KEYPAD_TASK,
	ENCODER_READ_TASK,
	NUM_TASKS /**< Number of tasks in the system */
} task_enum_t;

/* --- Static Global Variables -----------------------------------------------*/

/**
 * @brief Queue to store COBS-encoded received data (one byte per queue entry).
 */
static QueueHandle_t encoded_reception_queue = NULL;

/**
 * @brief Queue to store data events to be sent to the host.
 */
static QueueHandle_t data_event_queue = NULL;

/**
 * @brief Stores various error counters and a global error state.
 */
static error_counters_t error_counters;

/**
 * @brief Stores properties (such as watermarks) for each task.
 */
static task_props_t task_props[NUM_TASKS];

/* --- Static Function Prototypes --------------------------------------------*/

/**
 * @brief Calculates the XOR checksum.
 *
 * @param[in] data   Pointer to the data.
 * @param[in] length Length of the data.
 * @return The calculated XOR checksum.
 */
static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length);

/**
 * @brief Task that receives data from UART (USB CDC) and posts to a reception queue.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void uart_event_task(void *pvParameters);

/**
 * @brief FreeRTOS task that runs TinyUSB device tasks.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void cdc_task(void *pvParameters);

/**
 * @brief Encodes and sends data via USB CDC, appending a packet marker at the end.
 *
 * @param[in] id         The ID of the device sending the data.
 * @param[in] command    The command to send.
 * @param[in] send_data  Pointer to the data to send.
 * @param[in] length     Length of the data to send.
 */
static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length);

/**
 * @brief Sends specific error counter status to the host.
 *
 * @param[in] index Index of the error counter to be sent.
 */
static inline void send_status(uint8_t index);

/**
 * @brief Sends the heap usage (high watermark) of each task to the host.
 */
void send_heap_status(void);

/**
 * @brief Processes a fully decoded inbound message.
 *
 * @param[in] rx_buffer Pointer to the data buffer containing decoded bytes.
 * @param[in] length    Length of the decoded data.
 */
static void process_inbound_data(const uint8_t *rx_buffer, size_t length);

/**
 * @brief Task that decodes bytes from the encoded reception queue using COBS.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void decode_reception_task(void *pvParameters);

/**
 * @brief Task that processes outbound messages from the `data_event_queue` and sends them to the host.
 *
 * @param[in] pvParameters Pointer to task parameters (task_props_t).
 */
static void process_outbound_task(void *pvParameters);

/**
 * @brief Sets up and initializes all required hardware resources.
 *
 * @return `true` if initialization was successful, `false` otherwise.
 */
static inline bool setup_hardware(void);

/**
 * @brief Enters an infinite loop indicating a critical error state.
 *        The LED blinks and the watchdog is updated periodically.
 */
static inline void enter_error_state(void);

/**
 * @brief Cleans up all allocated resources such as queues and tasks.
 */
static inline void clean_up(void);

/* --- Function Definitions --------------------------------------------------*/

static inline uint8_t calculate_checksum(const uint8_t *data, uint8_t length)
{
	uint8_t checksum = 0;
	for (uint8_t i = 0; i < length; i++)
	{
		checksum ^= data[i];
	}
	return checksum;
}

static void uart_event_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];

	for (;;)
	{
		/* Track free stack space for debugging */
		task_prop->high_watermark = (uint8_t)uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();

		if (!tud_cdc_n_available(0))
		{
			/* No data available, yield to other tasks */
			taskYIELD();
			continue;
		}

		uint32_t count = tud_cdc_n_read(0, receive_buffer, sizeof(receive_buffer));
		for (uint32_t i = 0; (i < count) && (i < MAX_ENCODED_BUFFER_SIZE); i++)
		{
			if (xQueueSend(encoded_reception_queue, &receive_buffer[i], portMAX_DELAY) != pdTRUE)
			{
				error_counters.counters[QUEUE_SEND_ERROR]++;
			}
		}
	}
}

static void cdc_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	for (;;)
	{
		/* TinyUSB device tasks */
		tud_task();

		if (tud_cdc_n_connected(0))
		{
			gpio_put(PICO_DEFAULT_LED_PIN, 1);
		}
		else
		{
			gpio_put(PICO_DEFAULT_LED_PIN, 0);
		}

		task_prop->high_watermark = (uint8_t)uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
	}
}

static void send_data(uint16_t id, uint8_t command, const uint8_t *send_data, uint8_t length)
{
	uint8_t uart_outbound_buffer[DATA_BUFFER_SIZE];

	/* Check for buffer overflow risk */
	if (length > (DATA_BUFFER_SIZE - HEADER_SIZE - CHECKSUM_SIZE))
	{
		error_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		return;
	}

	/* Compose header */
	id <<= 5;
	uart_outbound_buffer[0] = (id >> 8);
	uart_outbound_buffer[1] = (id & 0xE0) | (command & 0x1F);
	uart_outbound_buffer[2] = length;

	memcpy(&uart_outbound_buffer[HEADER_SIZE], send_data, length);

	/* Calculate and store checksum */
	uint8_t checksum = calculate_checksum(uart_outbound_buffer, (uint8_t)(length + HEADER_SIZE));
	uart_outbound_buffer[HEADER_SIZE + length] = checksum;

	uint8_t encode_buffer[MAX_ENCODED_BUFFER_SIZE];
	size_t num_encoded = cobs_encode(uart_outbound_buffer, length + HEADER_SIZE + CHECKSUM_SIZE, encode_buffer);

	/* Check for buffer overflow after encoding */
	if (num_encoded + 1 >= MAX_ENCODED_BUFFER_SIZE)
	{
		error_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		return;
	}

	/* Append marker */
	encode_buffer[num_encoded] = PACKET_MARKER;

	/* Send via USB CDC */
	for (uint8_t i = 0; i < num_encoded + 1; i++)
	{
		tud_cdc_n_write_char(0, encode_buffer[i]);
	}
	tud_cdc_write_flush();
}

static inline void send_status(uint8_t index)
{
	uint8_t data[2] = {0, 0};

	if (index < NUM_ERROR_COUNTERS)
	{
		data[0] = index;
		data[1] = (uint8_t)(error_counters.counters[index] >> 8);
		data[2] = (uint8_t)(error_counters.counters[index] & 0xFF);
	}

	send_data(PANEL_ID, PC_STATUS_CMD, data, sizeof(data));
}

void send_heap_status(void)
{
	uint8_t data[7] = {0};

	for (uint8_t t = 0; t < NUM_TASKS; t++)
	{
		data[t] = task_props[t].high_watermark;
	}

	send_data(PANEL_ID, PC_HEAP_STATUS_CMD, data, sizeof(data));
}

static void process_inbound_data(const uint8_t *rx_buffer, size_t length)
{
	if (length < (HEADER_SIZE + CHECKSUM_SIZE))
	{
		/* Not enough data to include header + checksum */
		error_counters.counters[MSG_MALFORMED_ERROR]++;
		return;
	}

	/* Decode ID, command, and length */
	uint16_t rxID = (uint16_t)(rx_buffer[0] << 3);
	rxID |= ((rx_buffer[1] & 0xE0) >> 5);
	uint8_t cmd = (uint8_t)(rx_buffer[1] & 0x1F);
	uint8_t len = rx_buffer[2];

	if (length != (len + HEADER_SIZE + CHECKSUM_SIZE))
	{
		error_counters.counters[MSG_MALFORMED_ERROR]++;
		return;
	}

	if (DATA_BUFFER_SIZE < len)
	{
		error_counters.counters[BUFFER_OVERFLOW_ERROR]++;
		return;
	}

	/* Verify checksum */
	uint8_t calculated_checksum = calculate_checksum(rx_buffer, (uint8_t)(len + HEADER_SIZE));
	uint8_t received_checksum = rx_buffer[len + HEADER_SIZE];

	if (calculated_checksum != received_checksum)
	{
		error_counters.counters[CHECKSUM_ERROR]++;
		return;
	}

	/* Copy payload data */
	uint8_t decoded_data[DATA_BUFFER_SIZE] = {0};
	memcpy(decoded_data, &rx_buffer[HEADER_SIZE], len);

	switch (cmd)
	{
	case PC_LEDOUT_CMD:
	{
		uint8_t leds[2];
		leds[0] = decoded_data[1];
		leds[1] = decoded_data[2];
		if (!led_out(decoded_data[0], leds, sizeof(leds)))
		{
			error_counters.counters[LED_OUT_ERROR]++;
		}
	}
	break;

	case PC_PWM_CMD:
		set_pwm_duty(decoded_data[0]);
		break;

	case PC_DPYCTL_CMD:
	{
		if (display_out(decoded_data, len) != len)
		{
			error_counters.counters[DISPLAY_OUT_ERROR]++;
		}
	}
	break;

	case PC_ECHO_CMD:
		send_data(rxID, cmd, decoded_data, len);
		break;

	case PC_STATUS_CMD:
		send_status(decoded_data[0]);
		break;

	case PC_HEAP_STATUS_CMD:
		send_heap_status();
		break;

	default:
		error_counters.counters[UNKNOWN_CMD_ERROR]++;
		break;
	}
}

static void decode_reception_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	uint8_t receive_buffer[MAX_ENCODED_BUFFER_SIZE];
	size_t receive_buffer_index = 0;

	for (;;)
	{
		task_prop->high_watermark = (uint8_t)uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();

		uint8_t data;
		if (pdFALSE == xQueueReceive(encoded_reception_queue, (void *)&data, portMAX_DELAY))
		{
			/* Failed to receive data from queue */
			error_counters.counters[QUEUE_RECEIVE_ERROR]++;
			continue;
		}

		if (PACKET_MARKER == data)
		{
			if (receive_buffer_index <= 0)
			{
				/* Packet marker received but no data in buffer */
				error_counters.counters[MSG_MALFORMED_ERROR]++;
				continue;
			}

			uint8_t decode_buffer[receive_buffer_index];
			size_t num_decoded = cobs_decode(receive_buffer, receive_buffer_index, decode_buffer);

			receive_buffer_index = 0;

			if (num_decoded > 0)
			{
				process_inbound_data(decode_buffer, num_decoded);
			}
		}
		else
		{
			if ((receive_buffer_index + 1) < MAX_ENCODED_BUFFER_SIZE)
			{
				receive_buffer[receive_buffer_index++] = data;
			}
			else
			{
				error_counters.counters[RECEIVE_BUFFER_OVERFLOW_ERROR]++;
			}
		}
	}
}

static void process_outbound_task(void *pvParameters)
{
	task_props_t *task_prop = (task_props_t *)pvParameters;
	for (;;)
	{
		data_events_t data_event;
		if (xQueueReceive(data_event_queue, (void *)&data_event, portMAX_DELAY))
		{
			send_data(PANEL_ID, data_event.command, data_event.data, data_event.data_length);
		}
		else
		{
			error_counters.counters[QUEUE_RECEIVE_ERROR]++;
		}

		task_prop->high_watermark = (uint8_t)uxTaskGetStackHighWaterMark(NULL);
		watchdog_update();
	}
}

static inline bool setup_hardware(void)
{
	/* Initialize standard I/O (UART, etc.) */
	stdio_init_all();

	/* Initialize outputs (LED, PWM, etc.) */
	output_init();

	/* Create data event queue */
	data_event_queue = xQueueCreate(DATA_EVENT_QUEUE_SIZE, sizeof(data_events_t));
	if (NULL == data_event_queue)
	{
		return false;
	}

	/* Inputs configuration (keypad, ADC, etc.) */
	const input_config_t config = {
		.columns               = 8,
		.rows                  = 8,
		.key_settling_time_ms  = 20,
		.input_event_queue     = data_event_queue,
		.adc_banks             = 2,
		.adc_channels          = 8,
		.adc_settling_time_ms  = 100,
		.encoder_settling_time_ms = 10,
		/* Enable encoder on row 8 (last row) */
		.encoder_mask          = { [7] = true }
	};
	input_init(&config);

	/* Reset all error counters */
	for (uint8_t i = 0; i < NUM_ERROR_COUNTERS; i++)
	{
		error_counters.counters[i] = 0;
	}

	/* Reset task props */
	for (uint8_t i = 0; i < NUM_TASKS; i++)
	{
		task_props[i].high_watermark = 0;
		task_props[i].task_handle    = NULL;
	}

	/* Watchdog 1s, pause on debug */
	watchdog_enable(1000, true);

	return true;
}

static inline void enter_error_state(void)
{
	bool state = true;
	for (;;)
	{
		state = !state;
		gpio_put(PICO_DEFAULT_LED_PIN, state);
		vTaskDelay(pdMS_TO_TICKS(500));
		watchdog_update();
	}
}

static inline void clean_up(void)
{
	/* Delete all queues */
	if (encoded_reception_queue)
	{
		vQueueDelete(encoded_reception_queue);
		encoded_reception_queue = NULL;
	}

	if (data_event_queue)
	{
		vQueueDelete(data_event_queue);
		data_event_queue = NULL;
	}

	/* Delete all tasks */
	for (uint8_t t = 0; t < NUM_TASKS; t++)
	{
		if (task_props[t].task_handle != NULL)
		{
			vTaskDelete(task_props[t].task_handle);
			task_props[t].task_handle = NULL;
		}
	}
}

/**
 * @brief Main entry point of the application.
 *
 * This function initializes the system (hardware, queues, tasks),
 * checks for watchdog resets, and starts the FreeRTOS scheduler. If
 * an error is detected, it enters an infinite loop (error state).
 *
 * @return Zero on normal exit. Usually never returns because of FreeRTOS.
 */
int main(void)
{
	BaseType_t success;
	error_counters.error_state = false;

	if (watchdog_caused_reboot())
	{
		error_counters.counters[WATCHDOG_ERROR]++;
		clean_up();
	}

	/* Initialize TinyUSB hardware/board */
	board_init();

	/* Initialize TinyUSB stack */
	if (!tud_init(BOARD_TUD_RHPORT))
	{
		error_counters.error_state = true;
	}

	/* Setup hardware, queues, etc. */
	if (!setup_hardware())
	{
		error_counters.error_state = true;
	}

	/* Create the CDC task */
	success = xTaskCreate(cdc_task,
	                      "cdc_task",
	                      CDC_STACK_SIZE,
	                      (void *)&task_props[CDC_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[CDC_TASK].task_handle);
	if (success != pdPASS)
	{
		error_counters.error_state = true;
	}

	/* Create queue for encoded data */
	encoded_reception_queue = xQueueCreate(ENCODED_QUEUE_SIZE, sizeof(uint8_t));
	if (encoded_reception_queue != NULL)
	{
		/* UART event task */
		success = xTaskCreate(uart_event_task,
		                      "uart_event_task",
		                      UART_EVENT_STACK_SIZE,
		                      (void *)&task_props[UART_EVENT_TASK],
		                      mainPROCESS_QUEUE_TASK_PRIORITY,
		                      &task_props[UART_EVENT_TASK].task_handle);
		if (success != pdPASS)
		{
			error_counters.error_state = true;
		}

		/* Decode reception task */
		success = xTaskCreate(decode_reception_task,
		                      "decode_reception_task",
		                      DECODE_RECEPTION_STACK_SIZE,
		                      (void *)&task_props[DECODE_RECEPTION_TASK],
		                      mainPROCESS_QUEUE_TASK_PRIORITY + 1,
		                      &task_props[DECODE_RECEPTION_TASK].task_handle);
		if (success != pdPASS)
		{
			error_counters.error_state = true;
		}
	}
	else
	{
		error_counters.error_state = true;
	}

	/* Outbound processing task */
	success = xTaskCreate(process_outbound_task,
	                      "process_outbound_task",
	                      PROCESS_OUTBOUND_STACK_SIZE,
	                      (void *)&task_props[PROCESS_OUTBOUND_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[PROCESS_OUTBOUND_TASK].task_handle);
	if (success != pdPASS)
	{
		error_counters.error_state = true;
	}

	/* ADC read task */
	success = xTaskCreate(adc_read_task,
	                      "adc_read_task",
	                      ADC_READ_STACK_SIZE,
	                      (void *)&task_props[ADC_READ_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[ADC_READ_TASK].task_handle);
	if (success != pdPASS)
	{
		error_counters.error_state = true;
	}

	/* Keypad task */
	success = xTaskCreate(keypad_task,
	                      "keypad_task",
	                      KEYPAD_STACK_SIZE,
	                      (void *)&task_props[KEYPAD_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[KEYPAD_TASK].task_handle);
	if (success != pdPASS)
	{
		error_counters.error_state = true;
	}

	/* Encoder read task */
	success = xTaskCreate(encoder_read_task,
	                      "encoder_task",
	                      ENCODER_READ_STACK_SIZE,
	                      (void *)&task_props[ENCODER_READ_TASK],
	                      mainPROCESS_QUEUE_TASK_PRIORITY,
	                      &task_props[ENCODER_READ_TASK].task_handle);
	if (success != pdPASS)
	{
		error_counters.error_state = true;
	}

	/* Start scheduler if no critical error was found */
	if (!error_counters.error_state)
	{
		vTaskStartScheduler();
	}
	else
	{
		enter_error_state();
	}

	return 0; /* Normally should never reach here */
}